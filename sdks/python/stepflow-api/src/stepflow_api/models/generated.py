# generated by datamodel-codegen:
#   filename:  openapi.json
#   timestamp: 2026-01-05T16:50:39+00:00

from __future__ import annotations

from enum import StrEnum
from typing import Annotated, Any, Literal
from uuid import UUID

from pydantic import AwareDatetime, BaseModel, Field, RootModel


class Step(BaseModel):
    step: str


class BaseRef2(BaseModel):
    step: Annotated[
        Step, Field(description="# StepReference\nReference the output of a step.")
    ]


class BatchStatistics(BaseModel):
    cancelledRuns: Annotated[int, Field(ge=0)]
    completedRuns: Annotated[int, Field(ge=0)]
    failedRuns: Annotated[int, Field(ge=0)]
    pausedRuns: Annotated[int, Field(ge=0)]
    runningRuns: Annotated[int, Field(ge=0)]


class BatchStatus(StrEnum):
    running = "running"
    cancelled = "cancelled"


class BlobId(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A type-safe wrapper for blob identifiers.\n\nBlob IDs are SHA-256 hashes of the content, providing deterministic\nidentification and automatic deduplication."
        ),
    ]


class CancelBatchResponse(BaseModel):
    batchId: Annotated[UUID, Field(description="The batch ID")]
    status: Annotated[BatchStatus, Field(description="The updated batch status")]


class Component(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Identifies a specific plugin and atomic functionality to execute.\n\nA component is identified by a path that specifies:\n- The plugin name\n- The component name within that plugin\n- Optional sub-path for specific functionality"
        ),
    ]


class CreateBatchResponse(BaseModel):
    batchId: Annotated[UUID, Field(description="The batch ID")]
    status: Annotated[BatchStatus, Field(description="The batch status")]
    totalInputs: Annotated[
        int, Field(description="Total number of inputs in the batch", ge=0)
    ]


class DebugRunnableResponse(BaseModel):
    runnableSteps: Annotated[list[str], Field(description="Steps that can be executed")]


class DebugStepRequest(BaseModel):
    stepIds: Annotated[list[str], Field(description="Step IDs to execute")]


class FlowInput(BaseModel):
    field: Annotated[
        str | None, Field(description="Optional field path within workflow input")
    ] = None


class Dependency1(BaseModel):
    flowInput: Annotated[FlowInput, Field(description="Comes from workflow input")]


class StepOutput(BaseModel):
    field: Annotated[
        str | None, Field(description="Optional field path within step output")
    ] = None
    optional: Annotated[
        bool,
        Field(
            description="If true, the step_id may be skipped and this step still executed."
        ),
    ]
    stepId: Annotated[str, Field(description="Which step produces this data")]


class Dependency2(BaseModel):
    stepOutput: Annotated[
        StepOutput, Field(description="Comes from another step's output")
    ]


class Dependency(RootModel[Dependency1 | Dependency2]):
    root: Annotated[
        Dependency1 | Dependency2, Field(description="Source of input data")
    ]


class DiagnosticLevel(StrEnum):
    fatal = "fatal"
    error = "error"
    warning = "warning"


class DiagnosticMessage1(BaseModel):
    stepId: str
    type: Literal["duplicateStepId"]


class DiagnosticMessage2(BaseModel):
    type: Literal["emptyStepId"]


class DiagnosticMessage3(BaseModel):
    fromStep: str
    toStep: str
    type: Literal["forwardReference"]


class DiagnosticMessage4(BaseModel):
    stepId: str
    type: Literal["selfReference"]


class DiagnosticMessage5(BaseModel):
    fromStep: str | None = None
    referencedStep: str
    type: Literal["undefinedStepReference"]


class DiagnosticMessage6(BaseModel):
    error: str
    field: str | None = None
    stepId: str | None = None
    type: Literal["invalidReferenceExpression"]


class DiagnosticMessage7(BaseModel):
    field: str
    reason: str
    stepId: str
    type: Literal["invalidFieldAccess"]


class DiagnosticMessage8(BaseModel):
    component: str
    error: str
    stepId: str
    type: Literal["invalidComponent"]


class DiagnosticMessage9(BaseModel):
    stepId: str
    type: Literal["emptyComponentName"]


class DiagnosticMessage10(BaseModel):
    field: str
    stepId: str
    type: Literal["schemaViolation"]
    violation: str


class DiagnosticMessage11(BaseModel):
    stepId: str
    type: Literal["mockComponent"]


class DiagnosticMessage12(BaseModel):
    stepId: str
    type: Literal["unreachableStep"]


class DiagnosticMessage13(BaseModel):
    type: Literal["missingWorkflowName"]


class DiagnosticMessage14(BaseModel):
    type: Literal["missingWorkflowDescription"]


class DiagnosticMessage15(BaseModel):
    field: str
    reason: str
    stepId: str
    type: Literal["unvalidatedFieldAccess"]


class DiagnosticMessage16(BaseModel):
    type: Literal["noPluginsConfigured"]


class DiagnosticMessage17(BaseModel):
    type: Literal["noRoutingRulesConfigured"]


class DiagnosticMessage18(BaseModel):
    plugin: str
    routePath: str
    ruleIndex: Annotated[int, Field(ge=0)]
    type: Literal["invalidRouteReference"]


class DiagnosticMessage19(BaseModel):
    plugin: str
    type: Literal["unusedPlugin"]


class DiagnosticMessage(
    RootModel[
        DiagnosticMessage1
        | DiagnosticMessage2
        | DiagnosticMessage3
        | DiagnosticMessage4
        | DiagnosticMessage5
        | DiagnosticMessage6
        | DiagnosticMessage7
        | DiagnosticMessage8
        | DiagnosticMessage9
        | DiagnosticMessage10
        | DiagnosticMessage11
        | DiagnosticMessage12
        | DiagnosticMessage13
        | DiagnosticMessage14
        | DiagnosticMessage15
        | DiagnosticMessage16
        | DiagnosticMessage17
        | DiagnosticMessage18
        | DiagnosticMessage19
    ]
):
    root: Annotated[
        DiagnosticMessage1
        | DiagnosticMessage2
        | DiagnosticMessage3
        | DiagnosticMessage4
        | DiagnosticMessage5
        | DiagnosticMessage6
        | DiagnosticMessage7
        | DiagnosticMessage8
        | DiagnosticMessage9
        | DiagnosticMessage10
        | DiagnosticMessage11
        | DiagnosticMessage12
        | DiagnosticMessage13
        | DiagnosticMessage14
        | DiagnosticMessage15
        | DiagnosticMessage16
        | DiagnosticMessage17
        | DiagnosticMessage18
        | DiagnosticMessage19,
        Field(description="Specific diagnostic message with context"),
    ]


class ErrorAction1(BaseModel):
    action: Literal["fail"]


class ErrorAction2(BaseModel):
    action: Literal["skip"]


class ErrorAction4(BaseModel):
    action: Literal["retry"]


class ExecutionStatus(StrEnum):
    running = "running"
    completed = "completed"
    failed = "failed"
    cancelled = "cancelled"
    paused = "paused"


class Skipped(BaseModel):
    reason: Annotated[
        str | None, Field(description="Optional reason for why the step was skipped.")
    ] = None


class FlowResult2(BaseModel):
    Skipped_1: Annotated[
        Skipped, Field(alias="Skipped", description="# Skipped\nThe step was skipped.")
    ]


class HealthQuery(BaseModel):
    error: Annotated[
        str | None,
        Field(description="Trigger an error for testing error response format"),
    ] = None


class HealthResponse(BaseModel):
    status: Annotated[str, Field(description="Service status")]
    timestamp: Annotated[
        str, Field(description="Timestamp when health was checked (RFC3339 format)")
    ]
    version: Annotated[str, Field(description="Service version")]


class JsonPath(RootModel[Any]):
    root: Annotated[
        Any,
        Field(
            description="JSON path expression to apply to the referenced value. May use `$` to reference the whole value. May also be a bare field name (without the leading $) if the referenced value is an object."
        ),
    ]


class ListBatchesQuery(BaseModel):
    flowName: Annotated[str | None, Field(description="Filter by flow name")] = None
    limit: Annotated[
        int | None, Field(description="Maximum number of results to return", ge=0)
    ] = None
    offset: Annotated[
        int | None, Field(description="Number of results to skip", ge=0)
    ] = None
    status: BatchStatus | None = None


class ListComponentsQuery(BaseModel):
    includeSchemas: Annotated[
        bool | None,
        Field(description="Whether to include schemas in the response (default: true)"),
    ] = None


class OverrideType(StrEnum):
    merge_patch = "merge_patch"
    json_patch = "json_patch"


class RunSummary(BaseModel):
    completedAt: AwareDatetime | None = None
    createdAt: AwareDatetime
    debugMode: bool
    flowId: BlobId
    flowLabel: str | None = None
    flowName: str | None = None
    runId: UUID
    status: ExecutionStatus


class SchemaRef(BaseModel):
    pass


class SkipAction1(BaseModel):
    action: Literal["skip"]


class StepOverride(BaseModel):
    field_type: Annotated[
        OverrideType | None,
        Field(
            alias="$type",
            description='The type of override to apply. Defaults to "merge_patch" if not specified.',
        ),
    ] = None
    value: Annotated[
        Any,
        Field(
            description="The override value to apply, interpreted based on the override type."
        ),
    ]


class StepStatus(StrEnum):
    blocked = "blocked"
    runnable = "runnable"
    running = "running"
    completed = "completed"
    skipped = "skipped"
    failed = "failed"


class PortRangeItem(RootModel[int]):
    root: Annotated[int, Field(ge=0)]


class TestServerHealthCheck(BaseModel):
    path: Annotated[
        str, Field(description='Path for health check endpoint (e.g., "/health").')
    ]
    retryAttempts: Annotated[
        int | None,
        Field(description="Number of retry attempts for health checks.", ge=0),
    ] = None
    retryDelayMs: Annotated[
        int | None,
        Field(description="Delay between retry attempts (in milliseconds).", ge=0),
    ] = None
    timeoutMs: Annotated[
        int | None,
        Field(description="Timeout for health check requests (in milliseconds).", ge=0),
    ] = None


class ValueDependencies1(BaseModel):
    object: Annotated[
        dict[str, list[Dependency]],
        Field(description="Value is an object with named fields"),
    ]


class ValueDependencies2(BaseModel):
    other: Annotated[
        list[Dependency],
        Field(description="Value is not an object (single value, array, etc.)"),
    ]


class ValueDependencies(RootModel[ValueDependencies1 | ValueDependencies2]):
    root: Annotated[
        ValueDependencies1 | ValueDependencies2,
        Field(description="How a value receives its input data"),
    ]


class ValueRef(RootModel[Any]):
    root: Annotated[
        Any,
        Field(
            description="Any JSON value (object, array, string, number, boolean, or null)"
        ),
    ]


class ValueTemplate(RootModel[Any]):
    root: Annotated[
        Any,
        Field(
            description="A value that can be either a literal JSON value or an expression that references other values using the $from syntax"
        ),
    ]


class WorkflowOverrides(BaseModel):
    steps: Annotated[
        dict[str, StepOverride],
        Field(description="Map of step ID to override specification"),
    ]


class WorkflowRef(RootModel[Literal["input"]]):
    root: Literal["input"]


class BaseRef1(BaseModel):
    workflow: Annotated[
        WorkflowRef,
        Field(description="# WorkflowReference\nReference properties of the workflow."),
    ]


class Variable(BaseModel):
    default: ValueRef | None = None
    variable: str


class BaseRef3(BaseModel):
    variable: Annotated[
        Variable,
        Field(description="# VariableReference\nReference a workflow variable."),
    ]


class BaseRef(RootModel[BaseRef1 | BaseRef2 | BaseRef3]):
    root: Annotated[
        BaseRef1 | BaseRef2 | BaseRef3,
        Field(
            description="An expression that can be either a literal value or a template expression."
        ),
    ]


class BatchMetadata(BaseModel):
    batchId: UUID
    createdAt: AwareDatetime
    flowId: BlobId
    flowName: str | None = None
    status: BatchStatus
    totalInputs: Annotated[int, Field(ge=0)]


class BatchRunInfo(RunSummary):
    batchInputIndex: Annotated[
        int, Field(description="Position in the batch input array", ge=0)
    ]


class ComponentInfo(BaseModel):
    component: Annotated[Component, Field(description="The component ID.")]
    description: Annotated[
        str | None, Field(description="Optional description of the component.")
    ] = None
    input_schema: SchemaRef | None = None
    output_schema: SchemaRef | None = None


class CreateBatchRequest(BaseModel):
    flowId: Annotated[BlobId, Field(description="The flow hash to execute")]
    inputs: Annotated[
        list[ValueRef],
        Field(description="Array of input data for each run in the batch"),
    ]
    maxConcurrency: Annotated[
        int | None,
        Field(
            description="Maximum number of concurrent executions (defaults to number of inputs if not specified)",
            ge=0,
        ),
    ] = None
    overrides: Annotated[
        WorkflowOverrides | None,
        Field(description="Optional workflow overrides to apply before execution"),
    ] = None


class CreateRunRequest(BaseModel):
    debug: Annotated[
        bool | None,
        Field(
            description="Whether to run in debug mode (pauses execution for step-by-step control)"
        ),
    ] = None
    flowId: Annotated[BlobId, Field(description="The flow hash to execute")]
    input: Annotated[ValueRef, Field(description="Input data for the flow")]
    overrides: Annotated[
        WorkflowOverrides | None,
        Field(description="Optional workflow overrides to apply before execution"),
    ] = None
    variables: Annotated[
        dict[str, ValueRef] | None,
        Field(
            description="Optional variables to provide for variable references in the workflow"
        ),
    ] = None


class Diagnostic(BaseModel):
    ignore: Annotated[
        bool, Field(description="Whether this diagnostic should be ignored by default")
    ]
    level: Annotated[DiagnosticLevel, Field(description="The severity level")]
    message: Annotated[
        DiagnosticMessage, Field(description="The diagnostic message and type")
    ]
    path: Annotated[
        list[str], Field(description="JSON path to the field with the issue")
    ]
    text: Annotated[str, Field(description="Human-readable message text")]


class Diagnostics(BaseModel):
    diagnostics: Annotated[list[Diagnostic], Field(description="All diagnostics found")]


class ErrorAction3(BaseModel):
    action: Literal["useDefault"]
    defaultValue: ValueTemplate | None = None


class ErrorAction(RootModel[ErrorAction1 | ErrorAction2 | ErrorAction3 | ErrorAction4]):
    root: ErrorAction1 | ErrorAction2 | ErrorAction3 | ErrorAction4


class ExampleInput(BaseModel):
    description: Annotated[
        str | None,
        Field(description="Optional description of what this example demonstrates."),
    ] = None
    input: Annotated[ValueRef, Field(description="The input data for this example.")]
    name: Annotated[
        str, Field(description="Name of the example input for display purposes.")
    ]


class Expr2(BaseModel):
    field_literal: Annotated[
        ValueRef,
        Field(
            alias="$literal",
            description="A literal value that should not be expanded for expressions.\nThis allows creating JSON values that contain `$from` without expansion.",
        ),
    ]


class FlowError(BaseModel):
    code: int
    data: ValueRef | None = None
    message: str


class FlowResult1(BaseModel):
    Success: Annotated[
        ValueRef, Field(description="# Success\nThe step execution was successful.")
    ]


class FlowResult3(BaseModel):
    Failed: Annotated[
        FlowError, Field(description="# Failed\nThe step failed with the given error.")
    ]


class FlowResult(RootModel[FlowResult1 | FlowResult2 | FlowResult3]):
    root: Annotated[
        FlowResult1 | FlowResult2 | FlowResult3,
        Field(description="The results of a step execution."),
    ]


class ListBatchRunsResponse(BaseModel):
    runs: Annotated[
        list[BatchRunInfo], Field(description="List of runs with batch context")
    ]


class ListBatchesResponse(BaseModel):
    batches: Annotated[list[BatchMetadata], Field(description="List of batch metadata")]


class ListComponentsResponse(BaseModel):
    components: Annotated[
        list[ComponentInfo], Field(description="List of available components")
    ]


class ListRunsResponse(BaseModel):
    runs: Annotated[list[RunSummary], Field(description="List of run summaries")]


class RunDetails(RunSummary):
    input: ValueRef
    overrides: WorkflowOverrides | None = None
    result: FlowResult | None = None


class SkipAction2(BaseModel):
    action: Literal["useDefault"]
    defaultValue: ValueRef | None = None


class SkipAction(RootModel[SkipAction1 | SkipAction2]):
    root: SkipAction1 | SkipAction2


class StepAnalysis(BaseModel):
    inputDepends: Annotated[
        ValueDependencies, Field(description="Input dependencies for this step")
    ]
    skipIfDepend: Dependency | None = None


class StepRunResponse(BaseModel):
    component: Annotated[
        str | None, Field(description="Component name/URL that this step executes")
    ] = None
    result: FlowResult | None = None
    status: Annotated[StepStatus, Field(description="Current status of the step")]
    stepId: Annotated[str, Field(description="Step ID")]
    stepIndex: Annotated[int, Field(description="Step index in the flow", ge=0)]


class TestCase(BaseModel):
    description: Annotated[
        str | None,
        Field(description="Optional description of what this test case verifies."),
    ] = None
    input: Annotated[
        ValueRef, Field(description="Input data for the workflow in this test case.")
    ]
    name: Annotated[str, Field(description="Unique identifier for the test case.")]
    output: FlowResult | None = None


class TestServerConfig(BaseModel):
    args: Annotated[
        list[str] | None, Field(description="Arguments for the server command.")
    ] = None
    command: Annotated[str, Field(description="Command to start the server.")]
    env: Annotated[
        dict[str, str] | None,
        Field(
            description="Environment variables for the server process.\nValues can contain placeholders like {port} which will be substituted."
        ),
    ] = None
    healthCheck: TestServerHealthCheck | None = None
    portRange: Annotated[
        list[PortRangeItem] | None,
        Field(
            description="Port range for automatic port allocation.\nIf not specified, a random available port will be used."
        ),
    ] = None
    shutdownTimeoutMs: Annotated[
        int | None,
        Field(
            description="Maximum time to wait for server shutdown (in milliseconds).",
            ge=0,
        ),
    ] = None
    startupTimeoutMs: Annotated[
        int | None,
        Field(
            description="Maximum time to wait for server startup (in milliseconds).",
            ge=0,
        ),
    ] = None
    workingDirectory: Annotated[
        str | None, Field(description="Working directory for the server process.")
    ] = None


class BatchDetails(BatchMetadata, BatchStatistics):
    completedAt: AwareDatetime | None = None


class BatchOutputInfo(BaseModel):
    batchInputIndex: Annotated[
        int, Field(description="Position in the batch input array", ge=0)
    ]
    result: FlowResult | None = None
    status: Annotated[ExecutionStatus, Field(description="The execution status")]


class CreateRunResponse(BaseModel):
    debug: Annotated[bool, Field(description="Whether this run is in debug mode")]
    result: FlowResult | None = None
    runId: Annotated[UUID, Field(description="The run ID")]
    status: Annotated[ExecutionStatus, Field(description="The run status")]


class DebugStepResponse(BaseModel):
    results: Annotated[
        dict[str, FlowResult], Field(description="Results of executed steps")
    ]


class Expr1(BaseModel):
    field_from: Annotated[
        BaseRef, Field(alias="$from", description="The source of the reference.")
    ]
    onSkip: SkipAction | None = None
    path: Annotated[
        JsonPath | None,
        Field(
            description="JSON path expression to apply to the referenced value.\n\nDefaults to `$` (the whole referenced value).\nMay also be a bare field name (without the leading $) if\nthe referenced value is an object."
        ),
    ] = None


class Expr(RootModel[Expr1 | Expr2 | ValueRef]):
    root: Annotated[
        Expr1 | Expr2 | ValueRef,
        Field(
            description="An expression that can be either a literal value or a template expression."
        ),
    ]


class GetBatchResponse(BatchDetails):
    pass


class ListBatchOutputsResponse(BaseModel):
    outputs: Annotated[
        list[BatchOutputInfo],
        Field(description="List of outputs sorted by batch_input_index"),
    ]


class ListStepRunsResponse(BaseModel):
    steps: Annotated[
        dict[str, StepRunResponse],
        Field(description="Dictionary of step run results keyed by step ID"),
    ]


class StepModel(BaseModel):
    component: Annotated[
        Component, Field(description="The component to execute in this step")
    ]
    id: Annotated[str, Field(description="Identifier for the step")]
    input: Annotated[
        ValueTemplate | None,
        Field(description="Arguments to pass to the component for this step"),
    ] = None
    inputSchema: SchemaRef | None = None
    metadata: Annotated[
        dict[str, Any] | None,
        Field(
            description="Extensible metadata for the step that can be used by tools and frameworks."
        ),
    ] = None
    mustExecute: Annotated[
        bool | None,
        Field(
            description="If true, this step must execute even if its output is not used by the workflow output.\nUseful for steps with side effects (e.g., writing to databases, sending notifications).\n\nNote: If the step has `skip_if` that evaluates to true, the step will still be skipped\nand its dependencies will not be forced to execute."
        ),
    ] = None
    onError: ErrorAction | None = None
    outputSchema: SchemaRef | None = None
    skipIf: Expr | None = None


class TestConfig(BaseModel):
    cases: Annotated[
        list[TestCase] | None, Field(description="Test cases for the workflow.")
    ] = None
    config: Annotated[
        Any | None,
        Field(
            description="Stepflow configuration specific to tests.\nCan reference server URLs using placeholders like {server_name.url}."
        ),
    ] = None
    servers: Annotated[
        dict[str, TestServerConfig] | None,
        Field(
            description="Test servers to start before running tests.\nKey is the server name, value is the server configuration."
        ),
    ] = None


class FlowV1(BaseModel):
    description: Annotated[
        str | None, Field(description="The description of the flow.")
    ] = None
    examples: Annotated[
        list[ExampleInput] | None,
        Field(
            description="Example inputs for the workflow that can be used for testing and UI dropdowns."
        ),
    ] = None
    inputSchema: SchemaRef | None = None
    metadata: Annotated[
        dict[str, Any] | None,
        Field(
            description="Extensible metadata for the flow that can be used by tools and frameworks."
        ),
    ] = None
    name: Annotated[str | None, Field(description="The name of the flow.")] = None
    output: Annotated[
        ValueTemplate | None,
        Field(
            description="The outputs of the flow, mapping output names to their values."
        ),
    ] = None
    outputSchema: SchemaRef | None = None
    steps: Annotated[
        list[StepModel] | None, Field(description="The steps to execute for the flow.")
    ] = None
    test: TestConfig | None = None
    variables: SchemaRef | None = None
    version: Annotated[str | None, Field(description="The version of the flow.")] = None


class Flow1(FlowV1):
    schema_: Annotated[
        Literal["https://stepflow.org/schemas/v1/flow.json"], Field(alias="schema")
    ]


class Flow(RootModel[Flow1]):
    root: Annotated[
        Flow1,
        Field(
            description="A workflow consisting of a sequence of steps and their outputs.\n\nA flow represents a complete workflow that can be executed. It contains:\n- A sequence of steps to execute\n- Named outputs that can reference step outputs\n\nFlows should not be cloned. They should generally be stored and passed as a\nreference or inside an `Arc`."
        ),
    ]


class FlowAnalysis(BaseModel):
    flow: Annotated[Flow, Field(description="The workflow reference")]
    flowId: Annotated[BlobId, Field(description="The workflow ID for this analysis")]
    outputDepends: Annotated[
        ValueDependencies, Field(description="Dependencies for the workflow output.")
    ]
    steps: Annotated[
        dict[str, StepAnalysis],
        Field(description="Step-by-step analysis keyed by step ID for easy lookup"),
    ]


class FlowResponse(BaseModel):
    allExamples: Annotated[
        list[ExampleInput] | None,
        Field(
            description="All available examples (includes both examples and test cases)"
        ),
    ] = None
    analysis: Annotated[
        FlowAnalysis, Field(description="Optional analysis of the flow")
    ]
    flow: Annotated[Flow, Field(description="The flow definition")]
    flowId: Annotated[BlobId, Field(description="The flow ID")]


class RunFlowResponse(BaseModel):
    flow: Annotated[Flow, Field(description="The flow definition")]
    flowId: Annotated[BlobId, Field(description="The flow hash")]


class StoreFlowRequest(BaseModel):
    flow: Annotated[Flow, Field(description="The flow to store")]


class AnalysisResult(BaseModel):
    analysis: FlowAnalysis | None = None
    diagnostics: Annotated[
        Diagnostics, Field(description="All diagnostics found during analysis")
    ]


class StoreFlowResponse(AnalysisResult):
    flowId: BlobId | None = None
