# This file was auto-generated by scripts/generate_api_client.py
# Do not edit manually - changes will be overwritten on regeneration.
#
# Generated from: openapi.json

from __future__ import annotations

from collections.abc import Mapping
from typing import TYPE_CHECKING, Any, TypeVar, cast

from attrs import define as _attrs_define
from attrs import field as _attrs_field

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_run_request_variables import CreateRunRequestVariables
    from ..models.workflow_overrides import WorkflowOverrides


T = TypeVar("T", bound="CreateRunRequest")


@_attrs_define
class CreateRunRequest:
    """Request to create/execute a flow.

    The `input` field is always an array of input values:
    - Single-item array `[value]`: Executes one run with `value` as input
    - Multi-item array `[v1, v2, ...]`: Executes multiple runs (batch mode)

    This design avoids ambiguity: to run a workflow with an array as input,
    wrap it in another array: `[[1, 2, 3]]` runs once with input `[1, 2, 3]`.

        Attributes:
            flow_id (str): A SHA-256 hash of the blob content, represented as a hexadecimal string.
            input_ (list[Any]): Input data for the flow - always an array (one element per run)
            overrides (WorkflowOverrides | Unset): Workflow overrides that can be applied to modify step behavior at
                runtime.

                Overrides are keyed by step ID and contain merge patches or other transformation
                specifications to modify step properties before execution.
            variables (CreateRunRequestVariables | Unset): Optional variables to provide for variable references in the
                workflow
            debug (bool | Unset): Whether to run in debug mode (pauses execution for step-by-step control)
            max_concurrency (int | None | Unset): Maximum concurrency for batch execution (only used when input is an array)
    """

    flow_id: str
    input_: list[Any]
    overrides: WorkflowOverrides | Unset = UNSET
    variables: CreateRunRequestVariables | Unset = UNSET
    debug: bool | Unset = UNSET
    max_concurrency: int | None | Unset = UNSET
    additional_properties: dict[str, Any] = _attrs_field(init=False, factory=dict)

    def to_dict(self) -> dict[str, Any]:
        flow_id = self.flow_id

        input_ = self.input_

        overrides: dict[str, Any] | Unset = UNSET
        if not isinstance(self.overrides, Unset):
            overrides = self.overrides.to_dict()

        variables: dict[str, Any] | Unset = UNSET
        if not isinstance(self.variables, Unset):
            variables = self.variables.to_dict()

        debug = self.debug

        max_concurrency: int | None | Unset
        if isinstance(self.max_concurrency, Unset):
            max_concurrency = UNSET
        else:
            max_concurrency = self.max_concurrency

        field_dict: dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update(
            {
                "flowId": flow_id,
                "input": input_,
            }
        )
        if overrides is not UNSET:
            field_dict["overrides"] = overrides
        if variables is not UNSET:
            field_dict["variables"] = variables
        if debug is not UNSET:
            field_dict["debug"] = debug
        if max_concurrency is not UNSET:
            field_dict["maxConcurrency"] = max_concurrency

        return field_dict

    @classmethod
    def from_dict(cls: type[T], src_dict: Mapping[str, Any]) -> T:
        from ..models.create_run_request_variables import CreateRunRequestVariables
        from ..models.workflow_overrides import WorkflowOverrides

        d = dict(src_dict)
        flow_id = d.pop("flowId")

        input_ = cast(list[Any], d.pop("input"))

        _overrides = d.pop("overrides", UNSET)
        overrides: WorkflowOverrides | Unset
        if isinstance(_overrides, Unset):
            overrides = UNSET
        else:
            overrides = WorkflowOverrides.from_dict(_overrides)

        _variables = d.pop("variables", UNSET)
        variables: CreateRunRequestVariables | Unset
        if isinstance(_variables, Unset):
            variables = UNSET
        else:
            variables = CreateRunRequestVariables.from_dict(_variables)

        debug = d.pop("debug", UNSET)

        def _parse_max_concurrency(data: object) -> int | None | Unset:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(int | None | Unset, data)

        max_concurrency = _parse_max_concurrency(d.pop("maxConcurrency", UNSET))

        create_run_request = cls(
            flow_id=flow_id,
            input_=input_,
            overrides=overrides,
            variables=variables,
            debug=debug,
            max_concurrency=max_concurrency,
        )

        create_run_request.additional_properties = d
        return create_run_request

    @property
    def additional_keys(self) -> list[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties
