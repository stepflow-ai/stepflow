# This file was auto-generated by scripts/generate_api_client.py
# Do not edit manually - changes will be overwritten on regeneration.
#
# Generated from: openapi.json

from __future__ import annotations

from collections.abc import Mapping
from typing import TYPE_CHECKING, Any, TypeVar, cast

from attrs import define as _attrs_define
from attrs import field as _attrs_field

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.on_error_default import OnErrorDefault
    from ..models.on_error_fail import OnErrorFail
    from ..models.on_error_retry import OnErrorRetry
    from ..models.step_metadata import StepMetadata
    from ..models.value_expr import ValueExpr


T = TypeVar("T", bound="Step")


@_attrs_define
class Step:
    """A step in a workflow that executes a component with specific arguments.

    Note: Step output schemas are stored in the flow's `types.steps` field,
    not on individual steps. This allows for shared `$defs` and avoids duplication.

        Attributes:
            id (str): Identifier for the step
            component (str): Identifies a specific plugin and atomic functionality to execute. Use component name for
                builtins (e.g., 'eval') or path format for plugins (e.g., '/python/udf').
            on_error (None | OnErrorDefault | OnErrorFail | OnErrorRetry | Unset):
            input_ (ValueExpr | Unset): A value expression that can contain literal data or references to other values.

                Valid forms:
                - Step reference: { "$step": "step_id", "path"?: "..." }
                - Input reference: { "$input": "path" }
                - Variable reference: { "$variable": "path", "default"?: ValueExpr }
                - Escaped literal: { "$literal": any }
                - Conditional: { "$if": ValueExpr, "then": ValueExpr, "else"?: ValueExpr }
                - Coalesce: { "$coalesce": [ValueExpr, ...] }
                - Array of expressions: [ValueExpr, ...]
                - Object with expression values: { key: ValueExpr, ... }
                - Primitive values: null, boolean, number, string
            must_execute (bool | None | Unset): If true, this step must execute even if its output is not used by the
                workflow output.
                Useful for steps with side effects (e.g., writing to databases, sending notifications).
            metadata (StepMetadata | Unset): Extensible metadata for the step that can be used by tools and frameworks.
    """

    id: str
    component: str
    on_error: None | OnErrorDefault | OnErrorFail | OnErrorRetry | Unset = UNSET
    input_: ValueExpr | Unset = UNSET
    must_execute: bool | None | Unset = UNSET
    metadata: StepMetadata | Unset = UNSET
    additional_properties: dict[str, Any] = _attrs_field(init=False, factory=dict)

    def to_dict(self) -> dict[str, Any]:
        from ..models.on_error_default import OnErrorDefault
        from ..models.on_error_fail import OnErrorFail
        from ..models.on_error_retry import OnErrorRetry

        id = self.id

        component = self.component

        on_error: dict[str, Any] | None | Unset
        if isinstance(self.on_error, Unset):
            on_error = UNSET
        elif isinstance(self.on_error, OnErrorFail):
            on_error = self.on_error.to_dict()
        elif isinstance(self.on_error, OnErrorDefault):
            on_error = self.on_error.to_dict()
        elif isinstance(self.on_error, OnErrorRetry):
            on_error = self.on_error.to_dict()
        else:
            on_error = self.on_error

        input_: dict[str, Any] | Unset = UNSET
        if not isinstance(self.input_, Unset):
            input_ = self.input_.to_dict()

        must_execute: bool | None | Unset
        if isinstance(self.must_execute, Unset):
            must_execute = UNSET
        else:
            must_execute = self.must_execute

        metadata: dict[str, Any] | Unset = UNSET
        if not isinstance(self.metadata, Unset):
            metadata = self.metadata.to_dict()

        field_dict: dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update(
            {
                "id": id,
                "component": component,
            }
        )
        if on_error is not UNSET:
            field_dict["onError"] = on_error
        if input_ is not UNSET:
            field_dict["input"] = input_
        if must_execute is not UNSET:
            field_dict["mustExecute"] = must_execute
        if metadata is not UNSET:
            field_dict["metadata"] = metadata

        return field_dict

    @classmethod
    def from_dict(cls: type[T], src_dict: Mapping[str, Any]) -> T:
        from ..models.on_error_default import OnErrorDefault
        from ..models.on_error_fail import OnErrorFail
        from ..models.on_error_retry import OnErrorRetry
        from ..models.step_metadata import StepMetadata
        from ..models.value_expr import ValueExpr

        d = dict(src_dict)
        id = d.pop("id")

        component = d.pop("component")

        def _parse_on_error(
            data: object,
        ) -> None | OnErrorDefault | OnErrorFail | OnErrorRetry | Unset:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                componentsschemas_error_action_type_0 = OnErrorFail.from_dict(data)

                return componentsschemas_error_action_type_0
            except (TypeError, ValueError, AttributeError, KeyError):
                pass
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                componentsschemas_error_action_type_1 = OnErrorDefault.from_dict(data)

                return componentsschemas_error_action_type_1
            except (TypeError, ValueError, AttributeError, KeyError):
                pass
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                componentsschemas_error_action_type_2 = OnErrorRetry.from_dict(data)

                return componentsschemas_error_action_type_2
            except (TypeError, ValueError, AttributeError, KeyError):
                pass
            return cast(
                None | OnErrorDefault | OnErrorFail | OnErrorRetry | Unset, data
            )

        on_error = _parse_on_error(d.pop("onError", UNSET))

        _input_ = d.pop("input", UNSET)
        input_: ValueExpr | Unset
        if isinstance(_input_, Unset):
            input_ = UNSET
        else:
            input_ = ValueExpr.from_dict(_input_)

        def _parse_must_execute(data: object) -> bool | None | Unset:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(bool | None | Unset, data)

        must_execute = _parse_must_execute(d.pop("mustExecute", UNSET))

        _metadata = d.pop("metadata", UNSET)
        metadata: StepMetadata | Unset
        if isinstance(_metadata, Unset):
            metadata = UNSET
        else:
            metadata = StepMetadata.from_dict(_metadata)

        step = cls(
            id=id,
            component=component,
            on_error=on_error,
            input_=input_,
            must_execute=must_execute,
            metadata=metadata,
        )

        step.additional_properties = d
        return step

    @property
    def additional_keys(self) -> list[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties
