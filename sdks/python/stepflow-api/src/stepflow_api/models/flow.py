# This file was auto-generated by scripts/generate_api_client.py
# Do not edit manually - changes will be overwritten on regeneration.
#
# Generated from: openapi.json

from __future__ import annotations

from collections.abc import Mapping
from typing import TYPE_CHECKING, Any, TypeVar, cast

from attrs import define as _attrs_define
from attrs import field as _attrs_field

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.example_input import ExampleInput
    from ..models.flow_metadata import FlowMetadata
    from ..models.flow_schema import FlowSchema
    from ..models.step import Step
    from ..models.test_config import TestConfig
    from ..models.value_expr import ValueExpr


T = TypeVar("T", bound="Flow")


@_attrs_define
class Flow:
    """# FlowV1

    Attributes:
        schema (str | Unset): The schema URL that identifies this workflow format version.
            Defaults to the V1 schema URL.
        name (None | str | Unset): The name of the flow.
        description (None | str | Unset): The description of the flow.
        version (None | str | Unset): The version of the flow.
        schemas (FlowSchema | Unset): Consolidated schema information for a flow.

            This struct contains all schema/type information for the flow in a single location,
            allowing shared `$defs` across all schemas and avoiding duplication.

            Serializes as a valid JSON Schema with `type: "object"` and flow-specific
            properties (`input`, `output`, `variables`, `steps`) under the `properties` key.
        steps (list[Step] | Unset): The steps to execute for the flow.
        output (ValueExpr | Unset): A value expression that can contain literal data or references to other values.

            Valid forms:
            - Step reference: { "$step": "step_id", "path"?: "..." }
            - Input reference: { "$input": "path" }
            - Variable reference: { "$variable": "path", "default"?: ValueExpr }
            - Escaped literal: { "$literal": any }
            - Conditional: { "$if": ValueExpr, "then": ValueExpr, "else"?: ValueExpr }
            - Coalesce: { "$coalesce": [ValueExpr, ...] }
            - Array of expressions: [ValueExpr, ...]
            - Object with expression values: { key: ValueExpr, ... }
            - Primitive values: null, boolean, number, string
        test (None | TestConfig | Unset):
        examples (list[ExampleInput] | None | Unset): Example inputs for the workflow that can be used for testing and
            UI dropdowns.
        metadata (FlowMetadata | Unset): Extensible metadata for the flow that can be used by tools and frameworks.
    """

    schema: str | Unset = UNSET
    name: None | str | Unset = UNSET
    description: None | str | Unset = UNSET
    version: None | str | Unset = UNSET
    schemas: FlowSchema | Unset = UNSET
    steps: list[Step] | Unset = UNSET
    output: ValueExpr | Unset = UNSET
    test: None | TestConfig | Unset = UNSET
    examples: list[ExampleInput] | None | Unset = UNSET
    metadata: FlowMetadata | Unset = UNSET
    additional_properties: dict[str, Any] = _attrs_field(init=False, factory=dict)

    def to_dict(self) -> dict[str, Any]:
        from ..models.test_config import TestConfig

        schema = self.schema

        name: None | str | Unset
        if isinstance(self.name, Unset):
            name = UNSET
        else:
            name = self.name

        description: None | str | Unset
        if isinstance(self.description, Unset):
            description = UNSET
        else:
            description = self.description

        version: None | str | Unset
        if isinstance(self.version, Unset):
            version = UNSET
        else:
            version = self.version

        schemas: dict[str, Any] | Unset = UNSET
        if not isinstance(self.schemas, Unset):
            schemas = self.schemas.to_dict()

        steps: list[dict[str, Any]] | Unset = UNSET
        if not isinstance(self.steps, Unset):
            steps = []
            for steps_item_data in self.steps:
                steps_item = steps_item_data.to_dict()
                steps.append(steps_item)

        output: dict[str, Any] | Unset = UNSET
        if not isinstance(self.output, Unset):
            output = self.output.to_dict()

        test: dict[str, Any] | None | Unset
        if isinstance(self.test, Unset):
            test = UNSET
        elif isinstance(self.test, TestConfig):
            test = self.test.to_dict()
        else:
            test = self.test

        examples: list[dict[str, Any]] | None | Unset
        if isinstance(self.examples, Unset):
            examples = UNSET
        elif isinstance(self.examples, list):
            examples = []
            for examples_type_0_item_data in self.examples:
                examples_type_0_item = examples_type_0_item_data.to_dict()
                examples.append(examples_type_0_item)

        else:
            examples = self.examples

        metadata: dict[str, Any] | Unset = UNSET
        if not isinstance(self.metadata, Unset):
            metadata = self.metadata.to_dict()

        field_dict: dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if schema is not UNSET:
            field_dict["schema"] = schema
        if name is not UNSET:
            field_dict["name"] = name
        if description is not UNSET:
            field_dict["description"] = description
        if version is not UNSET:
            field_dict["version"] = version
        if schemas is not UNSET:
            field_dict["schemas"] = schemas
        if steps is not UNSET:
            field_dict["steps"] = steps
        if output is not UNSET:
            field_dict["output"] = output
        if test is not UNSET:
            field_dict["test"] = test
        if examples is not UNSET:
            field_dict["examples"] = examples
        if metadata is not UNSET:
            field_dict["metadata"] = metadata

        return field_dict

    @classmethod
    def from_dict(cls: type[T], src_dict: Mapping[str, Any]) -> T:
        from ..models.example_input import ExampleInput
        from ..models.flow_metadata import FlowMetadata
        from ..models.flow_schema import FlowSchema
        from ..models.step import Step
        from ..models.test_config import TestConfig
        from ..models.value_expr import ValueExpr

        d = dict(src_dict)
        schema = d.pop("schema", UNSET)

        def _parse_name(data: object) -> None | str | Unset:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(None | str | Unset, data)

        name = _parse_name(d.pop("name", UNSET))

        def _parse_description(data: object) -> None | str | Unset:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(None | str | Unset, data)

        description = _parse_description(d.pop("description", UNSET))

        def _parse_version(data: object) -> None | str | Unset:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(None | str | Unset, data)

        version = _parse_version(d.pop("version", UNSET))

        _schemas = d.pop("schemas", UNSET)
        schemas: FlowSchema | Unset
        if isinstance(_schemas, Unset):
            schemas = UNSET
        else:
            schemas = FlowSchema.from_dict(_schemas)

        _steps = d.pop("steps", UNSET)
        steps: list[Step] | Unset = UNSET
        if _steps is not UNSET:
            steps = []
            for steps_item_data in _steps:
                steps_item = Step.from_dict(steps_item_data)

                steps.append(steps_item)

        _output = d.pop("output", UNSET)
        output: ValueExpr | Unset
        if isinstance(_output, Unset):
            output = UNSET
        else:
            output = ValueExpr.from_dict(_output)

        def _parse_test(data: object) -> None | TestConfig | Unset:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                test_type_1 = TestConfig.from_dict(data)

                return test_type_1
            except (TypeError, ValueError, AttributeError, KeyError):
                pass
            return cast(None | TestConfig | Unset, data)

        test = _parse_test(d.pop("test", UNSET))

        def _parse_examples(data: object) -> list[ExampleInput] | None | Unset:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, list):
                    raise TypeError()
                examples_type_0 = []
                _examples_type_0 = data
                for examples_type_0_item_data in _examples_type_0:
                    examples_type_0_item = ExampleInput.from_dict(
                        examples_type_0_item_data
                    )

                    examples_type_0.append(examples_type_0_item)

                return examples_type_0
            except (TypeError, ValueError, AttributeError, KeyError):
                pass
            return cast(list[ExampleInput] | None | Unset, data)

        examples = _parse_examples(d.pop("examples", UNSET))

        _metadata = d.pop("metadata", UNSET)
        metadata: FlowMetadata | Unset
        if isinstance(_metadata, Unset):
            metadata = UNSET
        else:
            metadata = FlowMetadata.from_dict(_metadata)

        flow = cls(
            schema=schema,
            name=name,
            description=description,
            version=version,
            schemas=schemas,
            steps=steps,
            output=output,
            test=test,
            examples=examples,
            metadata=metadata,
        )

        flow.additional_properties = d
        return flow

    @property
    def additional_keys(self) -> list[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties
