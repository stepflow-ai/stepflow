#!/usr/bin/env python3
# Copyright 2025 DataStax Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.

"""Generate API endpoint modules from OpenAPI spec.

This script generates simple httpx-based endpoint functions from an OpenAPI spec.
It's designed to work with models generated by datamodel-code-generator.

Usage:
    python generate_endpoints.py <openapi.json> <output_dir>
"""

import json
import re
import sys
from pathlib import Path
from typing import Any


def camel_to_snake(name: str) -> str:
    """Convert CamelCase to snake_case."""
    s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
    return re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()


def get_python_type(schema: dict[str, Any], spec: dict[str, Any]) -> str:
    """Convert OpenAPI schema to Python type hint."""
    if "$ref" in schema:
        ref = schema["$ref"].split("/")[-1]
        return ref

    if "oneOf" in schema:
        types = [get_python_type(s, spec) for s in schema["oneOf"]]
        return " | ".join(types)

    if "allOf" in schema:
        # For allOf, typically take the first concrete type
        for s in schema["allOf"]:
            if "$ref" in s:
                return get_python_type(s, spec)
        return "Any"

    schema_type = schema.get("type", "object")

    if schema_type == "string":
        return "str"
    elif schema_type == "integer":
        return "int"
    elif schema_type == "number":
        return "float"
    elif schema_type == "boolean":
        return "bool"
    elif schema_type == "array":
        items = schema.get("items", {})
        item_type = get_python_type(items, spec)
        return f"list[{item_type}]"
    elif schema_type == "object":
        return "dict[str, Any]"
    elif schema_type == "null":
        return "None"

    return "Any"


def generate_endpoint_module(
    path: str,
    method: str,
    operation: dict[str, Any],
    spec: dict[str, Any],
) -> str:
    """Generate a single endpoint module."""
    operation_id = operation.get("operationId", f"{method}_{path}")
    func_name = camel_to_snake(operation_id)
    summary = operation.get("summary", "")
    description = operation.get("description", summary)

    # Collect parameters
    params = operation.get("parameters", [])
    path_params = [p for p in params if p.get("in") == "path"]
    query_params = [p for p in params if p.get("in") == "query"]

    # Check for request body
    request_body = operation.get("requestBody", {})
    body_schema = None
    body_type = None
    if request_body:
        content = request_body.get("content", {})
        if "application/json" in content:
            body_schema = content["application/json"].get("schema", {})
            body_type = get_python_type(body_schema, spec)

    # Get response type
    responses = operation.get("responses", {})
    success_response = responses.get("200", responses.get("201", {}))
    response_schema = None
    response_type = "Any"
    if success_response:
        content = success_response.get("content", {})
        if "application/json" in content:
            response_schema = content["application/json"].get("schema", {})
            response_type = get_python_type(response_schema, spec)

    # Build function signature
    sig_parts = ["client: Client"]

    for p in path_params:
        param_name = camel_to_snake(p["name"])
        param_type = get_python_type(p.get("schema", {}), spec)
        sig_parts.append(f"{param_name}: {param_type}")

    if body_type:
        sig_parts.append(f"body: {body_type}")

    for p in query_params:
        param_name = camel_to_snake(p["name"])
        param_type = get_python_type(p.get("schema", {}), spec)
        required = p.get("required", False)
        if not required:
            sig_parts.append(f"{param_name}: {param_type} | None = None")
        else:
            sig_parts.append(f"{param_name}: {param_type}")

    signature = ", ".join(sig_parts)

    # Build URL with path parameters
    url_path = path
    for p in path_params:
        url_path = url_path.replace(
            "{" + p["name"] + "}", "{" + camel_to_snake(p["name"]) + "}"
        )

    # Build query params dict
    query_param_lines = []
    for p in query_params:
        param_name = camel_to_snake(p["name"])
        api_name = p["name"]
        query_param_lines.append(
            f'        if {param_name} is not None: params["{api_name}"] = {param_name}'
        )

    query_params_code = ""
    if query_param_lines:
        query_params_code = """
        params: dict[str, Any] = {}
""" + "\n".join(query_param_lines)

    # Generate imports
    imports = [
        "from __future__ import annotations",
        "",
        "from typing import Any",
        "",
        "import httpx",
        "",
        "from ..client import Client",
    ]

    # Add model imports if needed
    model_imports = set()
    if body_type and body_type not in ("Any", "str", "int", "float", "bool", "None"):
        if not body_type.startswith("list[") and not body_type.startswith("dict["):
            model_imports.add(body_type)
    if response_type and response_type not in (
        "Any",
        "str",
        "int",
        "float",
        "bool",
        "None",
    ):
        if not response_type.startswith("list[") and not response_type.startswith(
            "dict["
        ):
            model_imports.add(response_type)

    if model_imports:
        imports.append(f"from ..models import {', '.join(sorted(model_imports))}")

    # Generate the module code
    code = "\n".join(imports)
    code += f'''


async def {func_name}({signature}) -> {response_type}:
    """{description}"""
    url = f"{{client.base_url}}{url_path}"'''

    if query_params_code:
        code += query_params_code

    if body_type:
        code += f"""
    response = await client.get_async_httpx_client().{method}(
        url,
        json=body if isinstance(body, dict) else body.__dict__,"""
        if query_param_lines:
            code += """
        params=params,"""
        code += """
    )"""
    else:
        code += f"""
    response = await client.get_async_httpx_client().{method}(
        url,"""
        if query_param_lines:
            code += """
        params=params,"""
        code += """
    )"""

    code += """
    response.raise_for_status()
    return response.json()
"""

    return code


def generate_init_file(endpoints: list[tuple[str, str, str]]) -> str:
    """Generate __init__.py that exports all endpoints."""
    lines = [
        '"""Generated API endpoints."""',
        "",
    ]

    # Group by tag
    by_tag: dict[str, list[tuple[str, str]]] = {}
    for tag, func_name, _ in endpoints:
        if tag not in by_tag:
            by_tag[tag] = []
        by_tag[tag].append((func_name, func_name))

    for tag, funcs in sorted(by_tag.items()):
        module_name = camel_to_snake(tag)
        func_names = [f[0] for f in funcs]
        lines.append(f"from .{module_name} import {', '.join(func_names)}")

    lines.append("")
    lines.append("__all__ = [")
    for _tag, funcs in sorted(by_tag.items()):
        for func_name, _ in funcs:
            lines.append(f'    "{func_name}",')
    lines.append("]")

    return "\n".join(lines)


def main():
    if len(sys.argv) != 3:
        print("Usage: python generate_endpoints.py <openapi.json> <output_dir>")
        sys.exit(1)

    spec_path = Path(sys.argv[1])
    output_dir = Path(sys.argv[2])

    with open(spec_path) as f:
        spec = json.load(f)

    # Create output directory
    api_dir = output_dir / "api"
    api_dir.mkdir(parents=True, exist_ok=True)

    endpoints: list[tuple[str, str, str]] = []  # (tag, func_name, module_code)

    for path, path_item in spec.get("paths", {}).items():
        for method in ["get", "post", "put", "delete", "patch"]:
            if method not in path_item:
                continue

            operation = path_item[method]
            tags = operation.get("tags", ["default"])
            tag = tags[0] if tags else "default"
            operation_id = operation.get("operationId", f"{method}_{path}")
            func_name = camel_to_snake(operation_id)

            code = generate_endpoint_module(path, method, operation, spec)
            endpoints.append((tag, func_name, code))

    # Group by tag and write files
    by_tag: dict[str, list[tuple[str, str]]] = {}
    for tag, func_name, code in endpoints:
        if tag not in by_tag:
            by_tag[tag] = []
        by_tag[tag].append((func_name, code))

    for tag, funcs in by_tag.items():
        module_name = camel_to_snake(tag)
        module_path = api_dir / f"{module_name}.py"

        # Merge all functions into one module per tag
        merged_imports = set()
        merged_functions = []

        for _func_name, code in funcs:
            # Extract imports and function
            lines = code.split("\n")
            in_imports = True
            func_lines = []
            for line in lines:
                if in_imports and (
                    line.startswith("from") or line.startswith("import") or line == ""
                ):
                    if line.startswith("from ..models"):
                        merged_imports.add(line)
                elif line.startswith("async def") or func_lines:
                    in_imports = False
                    func_lines.append(line)

            merged_functions.append("\n".join(func_lines))

        # Write the module
        with open(module_path, "w") as f:
            f.write(f'"""Generated API endpoints for {tag}."""\n\n')
            f.write("from __future__ import annotations\n\n")
            f.write("from typing import Any\n\n")
            f.write("import httpx\n\n")
            f.write("from ..client import Client\n")
            for imp in sorted(merged_imports):
                f.write(f"{imp}\n")
            f.write("\n\n")
            f.write("\n\n".join(merged_functions))

    # Write __init__.py for api directory
    with open(api_dir / "__init__.py", "w") as f:
        f.write(generate_init_file(endpoints))

    print(f"Generated {len(endpoints)} endpoints in {api_dir}")


if __name__ == "__main__":
    main()
