#!/usr/bin/env python3
# Copyright 2025 DataStax Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.

"""Generate stepflow-api from the OpenAPI spec.

Generates the full API client including models/ and api/ directories using
openapi-generator-cli via uvx (https://github.com/OpenAPITools/openapi-generator),
then post-processes to add generated file headers.

Requirements:
    - Java Runtime Environment (JRE) 11+ must be installed
    - uv (for uvx command)

Usage:
    python scripts/generate_api_client.py              # Regenerate from stored spec
    python scripts/generate_api_client.py generate     # Same as above
    python scripts/generate_api_client.py generate --from FILE
    python scripts/generate_api_client.py check        # Check if up-to-date

To update the OpenAPI spec, run from stepflow-rs:
    STEPFLOW_OVERWRITE_SCHEMA=1 cargo test -p stepflow-server \\
        test_openapi_schema_generation
"""

from __future__ import annotations

import argparse
import hashlib
import re
import shutil
import subprocess
import sys
import tempfile
from pathlib import Path

SCRIPT_DIR = Path(__file__).parent
PYTHON_SDK_DIR = SCRIPT_DIR.parent
PROJECT_ROOT = PYTHON_SDK_DIR.parent.parent
API_CLIENT_DIR = PYTHON_SDK_DIR / "stepflow-py"
SRC_DIR = API_CLIENT_DIR / "src" / "stepflow_py" / "api"
STORED_SPEC = PROJECT_ROOT / "schemas" / "openapi.json"

# Header added to all generated Python files
GENERATED_HEADER = """\
# This file was auto-generated by scripts/generate_api_client.py
# Do not edit manually - changes will be overwritten on regeneration.
#
# Generated from: {spec_file}

"""

# Global for cleanup
_temp_dir: Path | None = None


def check_java_installed() -> bool:
    """Check if Java is installed and available."""
    try:
        result = subprocess.run(
            ["java", "-version"],
            capture_output=True,
            check=False,
        )
        return result.returncode == 0
    except FileNotFoundError:
        return False


def run_openapi_generator(spec_file: Path, output_dir: Path) -> Path:
    """Run openapi-generator to generate the client.

    Uses uvx to run openapi-generator-cli from PyPI, which requires Java.
    """
    print(">>> Running openapi-generator...")

    if not check_java_installed():
        print("ERROR: Java Runtime Environment (JRE) is required but not found.")
        print("Install Java 11+ from: https://adoptium.net/")
        print("  macOS: brew install openjdk@11")
        print("  Ubuntu: sudo apt install openjdk-11-jre")
        sys.exit(1)

    # Remove existing output if present
    generated_dir = output_dir / "stepflow-api"
    if generated_dir.exists():
        shutil.rmtree(generated_dir)

    # Run openapi-generator via uvx (uses the PyPI package)
    # Pin to a stable version for reproducible builds
    # Use library=asyncio for native async support with aiohttp
    # Use packageName=stepflow_py.api to generate with correct import paths directly
    result = subprocess.run(
        [
            "uvx",
            "openapi-generator-cli@7.10.0",
            "generate",
            "-i",
            str(spec_file.resolve()),
            "-g",
            "python",
            "-o",
            str(generated_dir),
            "--additional-properties=packageName=stepflow_py.api,library=asyncio",
        ],
        capture_output=True,
        text=True,
    )

    if result.returncode != 0:
        print(f"ERROR: openapi-generator failed:\n{result.stderr}")
        sys.exit(1)

    return generated_dir


def add_generated_headers(directory: Path, spec_name: str) -> None:
    """Add 'generated file' header to all Python files."""
    print(">>> Adding generated file headers...")
    header = GENERATED_HEADER.format(spec_file=spec_name)

    count = 0
    for py_file in directory.rglob("*.py"):
        content = py_file.read_text()

        # Skip if already has the header
        if content.startswith("# This file was auto-generated"):
            continue

        # Prepend header to all files
        py_file.write_text(header + content)
        count += 1

    print(f"    Added headers to {count} files")


def format_files(directory: Path) -> None:
    """Format files with ruff."""
    print(">>> Formatting with ruff...")
    subprocess.run(
        [
            "uvx",
            "ruff@0.9.4",
            "format",
            "--config",
            str(PYTHON_SDK_DIR / "pyproject.toml"),
            str(directory),
        ],
        capture_output=True,
    )
    subprocess.run(
        [
            "uvx",
            "ruff@0.9.4",
            "check",
            "--fix",
            "--config",
            str(PYTHON_SDK_DIR / "pyproject.toml"),
            str(directory),
        ],
        capture_output=True,
    )


# Serializer code to add to oneOf models for proper JSON serialization.
# OpenAPI Generator's Python client creates wrapper classes for oneOf types with
# internal validation fields (oneof_schema_N_validator, actual_instance, etc.).
# Pydantic's default model_dump() serializes ALL fields, but the API expects only
# the unwrapped actual_instance value.
#
# This is a known issue in OpenAPI Generator:
# https://github.com/OpenAPITools/openapi-generator/issues/21892
#
# When the upstream issue is fixed, this workaround can be removed.
ONEOF_SERIALIZER_CODE = '''
    @model_serializer(mode='plain')
    def _serialize(self) -> Any:
        """Serialize by returning only the actual_instance, ignoring wrapper fields."""
        return self.actual_instance
'''

# Models that need the custom serializer (oneOf wrapper types)
ONEOF_MODELS = [
    "value_expr.py",
    "primitive_value.py",
    "error_action.py",
    "flow_result.py",
]


def add_oneof_serializers(directory: Path) -> None:
    """Add custom serializers to oneOf wrapper models for proper JSON output."""
    print(">>> Adding oneOf serializers...")
    models_dir = directory / "models"
    count = 0

    for model_file in ONEOF_MODELS:
        filepath = models_dir / model_file
        if not filepath.exists():
            continue

        content = filepath.read_text()

        # Skip if already patched
        if "@model_serializer" in content:
            continue

        # Add model_serializer import - handle both single-line and multi-line imports
        # Multi-line: from pydantic import (\n    BaseModel,\n    ...
        # Single-line: from pydantic import BaseModel, ConfigDict
        if "from pydantic import (" in content:
            # Multi-line import - add before closing paren
            content = re.sub(
                r"(from pydantic import \([^)]*)(field_validator,)(\s*\))",
                r"\1\2\n    model_serializer,\3",
                content,
            )
        elif "from pydantic import" in content:
            # Single-line import
            content = content.replace(
                "from pydantic import",
                "from pydantic import model_serializer,",
            )

        # Find the class definition and add the serializer after model_config
        # The ConfigDict block spans multiple lines and may contain nested parens,
        # so we match "model_config = ConfigDict(\n...)\n" ending with ")\n"
        pattern = r"(model_config = ConfigDict\([\s\S]*?\n    \),?\n)"
        match = re.search(pattern, content)
        if match:
            # Insert serializer after model_config
            insert_pos = match.end()
            content = (
                content[:insert_pos] + ONEOF_SERIALIZER_CODE + content[insert_pos:]
            )
            filepath.write_text(content)
            count += 1

    print(f"    Added serializers to {count} models")


def exclude_additional_properties(directory: Path) -> None:
    """Mark additional_properties fields as excluded from serialization.

    OpenAPI Generator creates an additional_properties field to capture extra
    JSON fields, but it shouldn't be included when serializing back to JSON.
    Adding exclude=True to the Field() ensures model_dump() and model_dump_json()
    won't include it.
    """
    print(">>> Excluding additional_properties from serialization...")
    models_dir = directory / "models"
    count = 0

    for filepath in models_dir.glob("*.py"):
        content = filepath.read_text()

        # Pattern: additional_properties: dict[str, Any] = {}
        # Replace with: Field(default={}, exclude=True)
        old_pattern = r"additional_properties: dict\[str, Any\] = \{\}"
        new_value = (
            "additional_properties: dict[str, Any] = Field(default={}, exclude=True)"
        )

        if re.search(old_pattern, content):
            content = re.sub(old_pattern, new_value, content)
            filepath.write_text(content)
            count += 1

    print(f"    Fixed {count} model files")


def fix_sanitize_for_serialization(directory: Path) -> None:
    """Fix sanitize_for_serialization to handle oneOf wrappers returning non-dicts.

    OneOf wrapper models like ValueExpr can return primitives from to_dict()
    when they wrap a primitive value. The default sanitize_for_serialization
    assumes to_dict() always returns a dict, causing AttributeError.

    This patch adds a check after to_dict() to recursively sanitize non-dict results.
    """
    print(">>> Fixing sanitize_for_serialization for oneOf wrappers...")
    api_client_path = directory / "api_client.py"

    if not api_client_path.exists():
        print("    api_client.py not found, skipping")
        return

    content = api_client_path.read_text()

    # Pattern to find the problematic block
    old_pattern = r'''(if hasattr\(obj, "to_dict"\) and callable\(obj\.to_dict\):
                obj_dict = obj\.to_dict\(\))
            else:'''

    # Replacement with the fix
    new_value = r'''if hasattr(obj, "to_dict") and callable(obj.to_dict):
                obj_dict = obj.to_dict()
                # Handle oneOf wrappers like ValueExpr that may return
                # non-dict values from to_dict() (e.g., primitives)
                if not isinstance(obj_dict, dict):
                    return self.sanitize_for_serialization(obj_dict)
            else:'''

    if re.search(old_pattern, content):
        content = re.sub(old_pattern, new_value, content)
        api_client_path.write_text(content)
        print("    Fixed sanitize_for_serialization in api_client.py")
    else:
        print("    Pattern not found (may already be patched)")


def copy_generated_files(src: Path, dest: Path) -> None:
    """Copy generated files to destination, preserving non-generated files."""
    print(f">>> Updating {dest}...")

    # openapi-generator generates to stepflow_py/api/ (nested, matching package name)
    # We copy to stepflow-py/src/stepflow_py/api/
    src_pkg = src / "stepflow_py" / "api"
    dest_pkg = dest / "src" / "stepflow_py" / "api"

    # Ensure destination exists
    dest_pkg.mkdir(parents=True, exist_ok=True)

    # Directories to fully replace (generated content)
    generated_dirs = ["api", "models"]

    for dirname in generated_dirs:
        src_dir = src_pkg / dirname
        dest_dir = dest_pkg / dirname
        if src_dir.exists():
            if dest_dir.exists():
                shutil.rmtree(dest_dir)
            shutil.copytree(src_dir, dest_dir)

    # Files to replace in package root (generated content)
    # openapi-generator generates different files than openapi-python-client:
    # - api_client.py (was client.py)
    # - exceptions.py (was errors.py)
    # - configuration.py, rest.py, api_response.py (new)
    generated_files = [
        "__init__.py",
        "api_client.py",
        "api_response.py",
        "configuration.py",
        "exceptions.py",
        "rest.py",
        "py.typed",
    ]
    for filename in generated_files:
        src_file = src_pkg / filename
        dest_file = dest_pkg / filename
        if src_file.exists():
            shutil.copy2(src_file, dest_file)

    # Remove old files that are no longer generated
    old_files = ["client.py", "errors.py", "types.py"]
    for filename in old_files:
        old_file = dest_pkg / filename
        if old_file.exists():
            old_file.unlink()
            print(f"    Removed obsolete file: {filename}")


def compute_dir_hash(directory: Path) -> str:
    """Compute a hash of all Python files in a directory."""
    hasher = hashlib.sha256()
    for py_file in sorted(directory.rglob("*.py")):
        content = py_file.read_text()
        # Skip the header line with spec file path (varies)
        lines = content.split("\n")
        # Skip first 5 lines (header)
        content_no_header = "\n".join(lines[5:])
        hasher.update(content_no_header.encode())
    return hasher.hexdigest()


def do_generate(spec_file: Path) -> None:
    """Generate client from a spec file."""
    global _temp_dir
    _temp_dir = Path(tempfile.mkdtemp())

    print(f">>> Using spec: {spec_file}")
    spec_name = spec_file.name

    # Generate to temp directory
    generated = run_openapi_generator(spec_file, _temp_dir)

    # openapi-generator generates to stepflow_py/api/ (nested, matching package name)
    generated_pkg = generated / "stepflow_py" / "api"

    # Add headers
    add_generated_headers(generated_pkg, spec_name)

    # Format
    format_files(generated)

    # Copy to destination
    copy_generated_files(generated, API_CLIENT_DIR)

    # Add custom serializers to oneOf wrapper models
    add_oneof_serializers(SRC_DIR)

    # Exclude additional_properties from serialization
    exclude_additional_properties(SRC_DIR)

    # Fix sanitize_for_serialization for oneOf wrappers
    fix_sanitize_for_serialization(SRC_DIR)

    # Format again after patches
    format_files(SRC_DIR)

    print(f">>> Updated: {API_CLIENT_DIR}")


def cmd_generate(args: argparse.Namespace) -> int:
    """Handle 'generate' subcommand."""
    if args.from_spec:
        spec_file = args.from_spec
        if not spec_file.exists():
            print(f"ERROR: Spec file not found: {spec_file}")
            return 1
    elif STORED_SPEC.exists():
        spec_file = STORED_SPEC
    else:
        print(f"ERROR: No stored spec at {STORED_SPEC}")
        print("Run 'update-spec' first to fetch from server.")
        return 1

    do_generate(spec_file)
    return 0


def cmd_check(args: argparse.Namespace) -> int:
    """Handle 'check' subcommand."""
    global _temp_dir
    _temp_dir = Path(tempfile.mkdtemp())

    print(">>> Checking if generated files match stored spec...")

    if not STORED_SPEC.exists():
        print(f"ERROR: No stored spec at {STORED_SPEC}")
        return 1

    # Generate fresh with all transformations (same as do_generate)
    generated = run_openapi_generator(STORED_SPEC, _temp_dir)
    generated_pkg = generated / "stepflow_py" / "api"
    add_generated_headers(generated_pkg, STORED_SPEC.name)
    format_files(generated)

    # Apply the same post-processing patches as do_generate
    add_oneof_serializers(generated_pkg)
    exclude_additional_properties(generated_pkg)
    fix_sanitize_for_serialization(generated_pkg)
    format_files(generated_pkg)

    # Compare hashes
    generated_hash = compute_dir_hash(generated_pkg)
    current_hash = compute_dir_hash(SRC_DIR)

    if generated_hash != current_hash:
        print("ERROR: Generated files are out of date!")
        print("\nTo fix: uv run python scripts/generate_api_client.py")
        return 1

    print(">>> Generated files are up-to-date")
    return 0


def main():
    parser = argparse.ArgumentParser(
        description="Generate stepflow-api from OpenAPI spec",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
subcommands:
  generate      Regenerate client from stored spec (default)
  check         Check if client is up-to-date with stored spec

examples:
  %(prog)s                          # Regenerate from stored spec
  %(prog)s generate --from FILE     # Regenerate from specific file
  %(prog)s check                    # Verify client is current

To update schemas/openapi.json, run from stepflow-rs:
  STEPFLOW_OVERWRITE_SCHEMA=1 cargo test -p stepflow-server \\
      test_openapi_schema_generation
""",
    )

    subparsers = parser.add_subparsers(dest="command", metavar="command")

    # generate subcommand
    gen_parser = subparsers.add_parser(
        "generate",
        help="Regenerate client from OpenAPI spec",
        description="Regenerate from stored OpenAPI spec or a specific file.",
    )
    gen_parser.add_argument(
        "--from",
        dest="from_spec",
        type=Path,
        metavar="FILE",
        help="Generate from specific spec file instead of stored spec",
    )

    # check subcommand
    subparsers.add_parser(
        "check",
        help="Check if client is up-to-date",
        description="Verify client matches stored spec. Exits non-zero if stale.",
    )

    args = parser.parse_args()

    print("=== stepflow-api generation ===")

    # Default to 'generate' if no subcommand given
    if args.command is None:
        args.command = "generate"
        args.from_spec = None

    if args.command == "generate":
        result = cmd_generate(args)
    elif args.command == "check":
        result = cmd_check(args)
    else:
        parser.print_help()
        result = 1

    print("=== Done ===")
    return result


if __name__ == "__main__":
    sys.exit(main())
