#!/usr/bin/env python3
# Copyright 2025 DataStax Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.

"""Generate stepflow-api from the OpenAPI spec.

Generates the full API client including models/ and api/ directories using
openapi-generator-cli via uvx (https://github.com/OpenAPITools/openapi-generator),
then post-processes to add generated file headers.

Requirements:
    - Java Runtime Environment (JRE) 11+ must be installed
    - uv (for uvx command)

Usage:
    python scripts/generate_api_client.py              # Regenerate from stored spec
    python scripts/generate_api_client.py generate     # Same as above
    python scripts/generate_api_client.py generate --from FILE
    python scripts/generate_api_client.py check        # Check if up-to-date
    python scripts/generate_api_client.py update-spec  # Update spec from server
    python scripts/generate_api_client.py update-spec --generate
"""

from __future__ import annotations

import argparse
import atexit
import hashlib
import re
import shutil
import signal
import subprocess
import sys
import tempfile
import time
import urllib.request
from pathlib import Path

SCRIPT_DIR = Path(__file__).parent
PYTHON_SDK_DIR = SCRIPT_DIR.parent
PROJECT_ROOT = PYTHON_SDK_DIR.parent.parent
API_CLIENT_DIR = PYTHON_SDK_DIR / "stepflow-py"
SRC_DIR = API_CLIENT_DIR / "src" / "stepflow_py" / "api"
STORED_SPEC = PROJECT_ROOT / "schemas" / "openapi.json"
PORT = 17837

# Header added to all generated Python files
GENERATED_HEADER = """\
# This file was auto-generated by scripts/generate_api_client.py
# Do not edit manually - changes will be overwritten on regeneration.
#
# Generated from: {spec_file}

"""

# Global for cleanup
_server_process: subprocess.Popen | None = None
_temp_dir: Path | None = None


def cleanup():
    """Clean up server process and temp directory."""
    global _server_process, _temp_dir
    if _server_process is not None:
        _server_process.terminate()
        try:
            _server_process.wait(timeout=5)
        except subprocess.TimeoutExpired:
            _server_process.kill()
        _server_process = None
    if _temp_dir is not None and _temp_dir.exists():
        shutil.rmtree(_temp_dir)
        _temp_dir = None


atexit.register(cleanup)
signal.signal(signal.SIGTERM, lambda *_: sys.exit(0))
signal.signal(signal.SIGINT, lambda *_: sys.exit(0))


def fetch_spec_from_server(output_path: Path) -> None:
    """Build and start server, fetch OpenAPI spec."""
    global _server_process

    print(">>> Building stepflow-server...")
    subprocess.run(
        ["cargo", "build", "--release", "-p", "stepflow-server"],
        cwd=PROJECT_ROOT / "stepflow-rs",
        check=True,
        capture_output=True,
    )

    print(f">>> Starting stepflow-server on port {PORT}...")
    server_bin = PROJECT_ROOT / "stepflow-rs" / "target" / "release" / "stepflow-server"
    _server_process = subprocess.Popen(
        [str(server_bin), "--port", str(PORT)],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )

    print(">>> Waiting for server to be ready...")
    for i in range(30):
        try:
            urllib.request.urlopen(f"http://localhost:{PORT}/api/v1/health", timeout=1)
            break
        except Exception as e:
            if i == 29:
                raise RuntimeError("Server failed to start") from e
            time.sleep(1)

    print(">>> Fetching OpenAPI spec...")
    with urllib.request.urlopen(f"http://localhost:{PORT}/api/v1/openapi.json") as resp:
        output_path.write_bytes(resp.read())

    _server_process.terminate()
    _server_process.wait()
    _server_process = None


def check_java_installed() -> bool:
    """Check if Java is installed and available."""
    try:
        result = subprocess.run(
            ["java", "-version"],
            capture_output=True,
            check=False,
        )
        return result.returncode == 0
    except FileNotFoundError:
        return False


def run_openapi_generator(spec_file: Path, output_dir: Path) -> Path:
    """Run openapi-generator to generate the client.

    Uses uvx to run openapi-generator-cli from PyPI, which requires Java.
    """
    print(">>> Running openapi-generator...")

    if not check_java_installed():
        print("ERROR: Java Runtime Environment (JRE) is required but not found.")
        print("Install Java 11+ from: https://adoptium.net/")
        print("  macOS: brew install openjdk@11")
        print("  Ubuntu: sudo apt install openjdk-11-jre")
        sys.exit(1)

    # Remove existing output if present
    generated_dir = output_dir / "stepflow-api"
    if generated_dir.exists():
        shutil.rmtree(generated_dir)

    # Run openapi-generator via uvx (uses the PyPI package)
    # Pin to a stable version for reproducible builds
    # Use library=asyncio for native async support with aiohttp
    # Use packageName=stepflow_py.api to generate with correct import paths directly
    result = subprocess.run(
        [
            "uvx",
            "openapi-generator-cli@7.10.0",
            "generate",
            "-i",
            str(spec_file.resolve()),
            "-g",
            "python",
            "-o",
            str(generated_dir),
            "--additional-properties=packageName=stepflow_py.api,library=asyncio",
        ],
        capture_output=True,
        text=True,
    )

    if result.returncode != 0:
        print(f"ERROR: openapi-generator failed:\n{result.stderr}")
        sys.exit(1)

    return generated_dir


def add_generated_headers(directory: Path, spec_name: str) -> None:
    """Add 'generated file' header to all Python files."""
    print(">>> Adding generated file headers...")
    header = GENERATED_HEADER.format(spec_file=spec_name)

    count = 0
    for py_file in directory.rglob("*.py"):
        content = py_file.read_text()

        # Skip if already has the header
        if content.startswith("# This file was auto-generated"):
            continue

        # Prepend header to all files
        py_file.write_text(header + content)
        count += 1

    print(f"    Added headers to {count} files")


def format_files(directory: Path) -> None:
    """Format files with ruff."""
    print(">>> Formatting with ruff...")
    subprocess.run(
        [
            "uvx",
            "ruff@0.9.4",
            "format",
            "--config",
            str(PYTHON_SDK_DIR / "pyproject.toml"),
            str(directory),
        ],
        capture_output=True,
    )
    subprocess.run(
        [
            "uvx",
            "ruff@0.9.4",
            "check",
            "--fix",
            "--config",
            str(PYTHON_SDK_DIR / "pyproject.toml"),
            str(directory),
        ],
        capture_output=True,
    )


# Serializer code to add to oneOf models for proper JSON serialization.
# OpenAPI Generator's Python client creates wrapper classes for oneOf types with
# internal validation fields (oneof_schema_N_validator, actual_instance, etc.).
# Pydantic's default model_dump() serializes ALL fields, but the API expects only
# the unwrapped actual_instance value.
#
# This is a known issue in OpenAPI Generator:
# https://github.com/OpenAPITools/openapi-generator/issues/21892
#
# When the upstream issue is fixed, this workaround can be removed.
ONEOF_SERIALIZER_CODE = '''
    @model_serializer(mode='plain')
    def _serialize(self) -> Any:
        """Serialize by returning only the actual_instance, ignoring wrapper fields."""
        return self.actual_instance
'''

# Models that need the custom serializer (oneOf wrapper types)
ONEOF_MODELS = [
    "value_expr.py",
    "primitive_value.py",
    "error_action.py",
    "flow_result.py",
    "diagnostic_message.py",
    "path_part.py",
]


def add_oneof_serializers(directory: Path) -> None:
    """Add custom serializers to oneOf wrapper models for proper JSON output."""
    print(">>> Adding oneOf serializers...")
    models_dir = directory / "models"
    count = 0

    for model_file in ONEOF_MODELS:
        filepath = models_dir / model_file
        if not filepath.exists():
            continue

        content = filepath.read_text()

        # Skip if already patched
        if "@model_serializer" in content:
            continue

        # Add model_serializer import - handle both single-line and multi-line imports
        # Multi-line: from pydantic import (\n    BaseModel,\n    ...
        # Single-line: from pydantic import BaseModel, ConfigDict
        if "from pydantic import (" in content:
            # Multi-line import - add before closing paren
            content = re.sub(
                r"(from pydantic import \([^)]*)(field_validator,)(\s*\))",
                r"\1\2\n    model_serializer,\3",
                content,
            )
        elif "from pydantic import" in content:
            # Single-line import
            content = content.replace(
                "from pydantic import",
                "from pydantic import model_serializer,",
            )

        # Find the class definition and add the serializer after model_config
        # The ConfigDict block spans multiple lines and may contain nested parens,
        # so we match "model_config = ConfigDict(\n...)\n" ending with ")\n"
        pattern = r"(model_config = ConfigDict\([\s\S]*?\n    \),?\n)"
        match = re.search(pattern, content)
        if match:
            # Insert serializer after model_config
            insert_pos = match.end()
            content = (
                content[:insert_pos] + ONEOF_SERIALIZER_CODE + content[insert_pos:]
            )
            filepath.write_text(content)
            count += 1

    print(f"    Added serializers to {count} models")


def fix_valueexpr_to_dict(directory: Path) -> None:
    """Fix ValueExpr.to_dict() to properly handle dict/list recursion."""
    print(">>> Fixing ValueExpr.to_dict()...")
    filepath = directory / "models" / "value_expr.py"

    if not filepath.exists():
        print("    WARNING: value_expr.py not found")
        return

    content = filepath.read_text()

    # The generated to_dict method doesn't handle dict/list recursion properly.
    # We replace the body to add dict/list handling while preserving the signature.
    # Match: if hasattr(...to_dict) -> return to_dict() else return actual_instance
    old_body = (
        'if hasattr(self.actual_instance, "to_dict") and callable(\n'
        "            self.actual_instance.to_dict\n"
        "        ):\n"
        "            return self.actual_instance.to_dict()\n"
        "        else:\n"
        "            # primitive type\n"
        "            return self.actual_instance"
    )

    new_body = (
        'if hasattr(self.actual_instance, "to_dict") and callable(\n'
        "            self.actual_instance.to_dict\n"
        "        ):\n"
        "            return self.actual_instance.to_dict()\n"
        "        elif isinstance(self.actual_instance, dict):\n"
        "            # Recursively convert dict values\n"
        "            return {\n"
        '                k: v.to_dict() if hasattr(v, "to_dict") else v\n'
        "                for k, v in self.actual_instance.items()\n"
        "            }\n"
        "        elif isinstance(self.actual_instance, list):\n"
        "            # Recursively convert list items\n"
        "            return [\n"
        '                item.to_dict() if hasattr(item, "to_dict") else item\n'
        "                for item in self.actual_instance\n"
        "            ]\n"
        "        else:\n"
        "            # primitive type\n"
        "            return self.actual_instance"
    )

    if old_body in content:
        content = content.replace(old_body, new_body)
        filepath.write_text(content)
        print("    Fixed ValueExpr.to_dict()")
    elif new_body in content:
        print("    ValueExpr.to_dict() already fixed")
    else:
        print("    WARNING: Could not find to_dict pattern to replace")


def exclude_additional_properties(directory: Path) -> None:
    """Mark additional_properties fields as excluded from serialization.

    OpenAPI Generator creates an additional_properties field to capture extra
    JSON fields, but it shouldn't be included when serializing back to JSON.
    Adding exclude=True to the Field() ensures model_dump() and model_dump_json()
    won't include it.
    """
    print(">>> Excluding additional_properties from serialization...")
    models_dir = directory / "models"
    count = 0

    for filepath in models_dir.glob("*.py"):
        content = filepath.read_text()

        # Pattern: additional_properties: dict[str, Any] = {}
        # Replace with: Field(default={}, exclude=True)
        old_pattern = r"additional_properties: dict\[str, Any\] = \{\}"
        new_value = (
            "additional_properties: dict[str, Any] = Field(default={}, exclude=True)"
        )

        if re.search(old_pattern, content):
            content = re.sub(old_pattern, new_value, content)
            filepath.write_text(content)
            count += 1

    print(f"    Fixed {count} model files")


def copy_generated_files(src: Path, dest: Path) -> None:
    """Copy generated files to destination, preserving non-generated files."""
    print(f">>> Updating {dest}...")

    # openapi-generator generates to stepflow_py/api/ (nested, matching package name)
    # We copy to stepflow-py/src/stepflow_py/api/
    src_pkg = src / "stepflow_py" / "api"
    dest_pkg = dest / "src" / "stepflow_py" / "api"

    # Ensure destination exists
    dest_pkg.mkdir(parents=True, exist_ok=True)

    # Directories to fully replace (generated content)
    generated_dirs = ["api", "models"]

    for dirname in generated_dirs:
        src_dir = src_pkg / dirname
        dest_dir = dest_pkg / dirname
        if src_dir.exists():
            if dest_dir.exists():
                shutil.rmtree(dest_dir)
            shutil.copytree(src_dir, dest_dir)

    # Files to replace in package root (generated content)
    # openapi-generator generates different files than openapi-python-client:
    # - api_client.py (was client.py)
    # - exceptions.py (was errors.py)
    # - configuration.py, rest.py, api_response.py (new)
    generated_files = [
        "__init__.py",
        "api_client.py",
        "api_response.py",
        "configuration.py",
        "exceptions.py",
        "rest.py",
        "py.typed",
    ]
    for filename in generated_files:
        src_file = src_pkg / filename
        dest_file = dest_pkg / filename
        if src_file.exists():
            shutil.copy2(src_file, dest_file)

    # Remove old files that are no longer generated
    old_files = ["client.py", "errors.py", "types.py"]
    for filename in old_files:
        old_file = dest_pkg / filename
        if old_file.exists():
            old_file.unlink()
            print(f"    Removed obsolete file: {filename}")


def compute_dir_hash(directory: Path) -> str:
    """Compute a hash of all Python files in a directory."""
    hasher = hashlib.sha256()
    for py_file in sorted(directory.rglob("*.py")):
        content = py_file.read_text()
        # Skip the header line with spec file path (varies)
        lines = content.split("\n")
        # Skip first 5 lines (header)
        content_no_header = "\n".join(lines[5:])
        hasher.update(content_no_header.encode())
    return hasher.hexdigest()


def do_generate(spec_file: Path) -> None:
    """Generate client from a spec file."""
    global _temp_dir
    _temp_dir = Path(tempfile.mkdtemp())

    print(f">>> Using spec: {spec_file}")
    spec_name = spec_file.name

    # Generate to temp directory
    generated = run_openapi_generator(spec_file, _temp_dir)

    # openapi-generator generates to stepflow_py/api/ (nested, matching package name)
    generated_pkg = generated / "stepflow_py" / "api"

    # Add headers
    add_generated_headers(generated_pkg, spec_name)

    # Format
    format_files(generated)

    # Copy to destination
    copy_generated_files(generated, API_CLIENT_DIR)

    # Add custom serializers to oneOf wrapper models
    add_oneof_serializers(SRC_DIR)

    # Fix ValueExpr.to_dict() to handle dict/list recursion
    fix_valueexpr_to_dict(SRC_DIR)

    # Exclude additional_properties from serialization
    exclude_additional_properties(SRC_DIR)

    # Format again after patches
    format_files(SRC_DIR)

    print(f">>> Updated: {API_CLIENT_DIR}")


def cmd_generate(args: argparse.Namespace) -> int:
    """Handle 'generate' subcommand."""
    if args.from_spec:
        spec_file = args.from_spec
        if not spec_file.exists():
            print(f"ERROR: Spec file not found: {spec_file}")
            return 1
    elif STORED_SPEC.exists():
        spec_file = STORED_SPEC
    else:
        print(f"ERROR: No stored spec at {STORED_SPEC}")
        print("Run 'update-spec' first to fetch from server.")
        return 1

    do_generate(spec_file)
    return 0


def cmd_check(args: argparse.Namespace) -> int:
    """Handle 'check' subcommand."""
    global _temp_dir
    _temp_dir = Path(tempfile.mkdtemp())

    print(">>> Checking if generated files match stored spec...")

    if not STORED_SPEC.exists():
        print(f"ERROR: No stored spec at {STORED_SPEC}")
        return 1

    # Generate fresh
    generated = run_openapi_generator(STORED_SPEC, _temp_dir)
    generated_pkg = generated / "stepflow_py" / "api"
    add_generated_headers(generated_pkg, STORED_SPEC.name)
    format_files(generated)

    # Compare hashes
    generated_hash = compute_dir_hash(generated_pkg)
    current_hash = compute_dir_hash(SRC_DIR)

    if generated_hash != current_hash:
        print("ERROR: Generated files are out of date!")
        print("\nTo fix: uv run python scripts/generate_api_client.py")
        return 1

    print(">>> Generated files are up-to-date")
    return 0


def cmd_update_spec(args: argparse.Namespace) -> int:
    """Handle 'update-spec' subcommand."""
    print(">>> Updating stored OpenAPI spec from server...")
    fetch_spec_from_server(STORED_SPEC)
    print(f">>> Stored spec updated: {STORED_SPEC}")

    if args.generate:
        print()
        do_generate(STORED_SPEC)

    return 0


def main():
    parser = argparse.ArgumentParser(
        description="Generate stepflow-api from OpenAPI spec",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
subcommands:
  generate      Regenerate client from stored spec (default)
  check         Check if client is up-to-date with stored spec
  update-spec   Fetch new spec from running stepflow-server

examples:
  %(prog)s                          # Regenerate from stored spec
  %(prog)s generate --from FILE     # Regenerate from specific file
  %(prog)s check                    # Verify client is current
  %(prog)s update-spec              # Fetch new spec from server
  %(prog)s update-spec --generate   # Fetch spec AND regenerate
""",
    )

    subparsers = parser.add_subparsers(dest="command", metavar="command")

    # generate subcommand
    gen_parser = subparsers.add_parser(
        "generate",
        help="Regenerate client from OpenAPI spec",
        description="Regenerate from stored OpenAPI spec or a specific file.",
    )
    gen_parser.add_argument(
        "--from",
        dest="from_spec",
        type=Path,
        metavar="FILE",
        help="Generate from specific spec file instead of stored spec",
    )

    # check subcommand
    subparsers.add_parser(
        "check",
        help="Check if client is up-to-date",
        description="Verify client matches stored spec. Exits non-zero if stale.",
    )

    # update-spec subcommand
    update_parser = subparsers.add_parser(
        "update-spec",
        help="Update stored spec from server",
        description="Build stepflow-server, run it, and fetch the OpenAPI spec.",
    )
    update_parser.add_argument(
        "--generate",
        action="store_true",
        help="Also regenerate client after updating spec",
    )

    args = parser.parse_args()

    print("=== stepflow-api generation ===")

    # Default to 'generate' if no subcommand given
    if args.command is None:
        args.command = "generate"
        args.from_spec = None

    if args.command == "generate":
        result = cmd_generate(args)
    elif args.command == "check":
        result = cmd_check(args)
    elif args.command == "update-spec":
        result = cmd_update_spec(args)
    else:
        parser.print_help()
        result = 1

    print("=== Done ===")
    return result


if __name__ == "__main__":
    sys.exit(main())
