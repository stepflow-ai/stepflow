{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "StepflowConfig",
  "allOf": [
    {
      "$ref": "#/$defs/RoutingConfig",
      "description": "Routing configuration for mapping components to plugins."
    },
    {
      "type": "object",
      "required": [
        "plugins"
      ],
      "properties": {
        "workingDirectory": {
          "type": [
            "string",
            "null"
          ],
          "description": "Working directory for the configuration.\n\nIf not set, this will be the directory containing the config."
        },
        "plugins": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/SupportedPluginConfig"
          },
          "propertyNames": {
            "type": "string"
          }
        },
        "storageConfig": {
          "$ref": "#/$defs/StorageConfig",
          "description": "Storage configuration. If not specified, uses in-memory storage."
        },
        "leaseManager": {
          "$ref": "#/$defs/LeaseManagerConfig",
          "description": "Lease manager configuration for distributed coordination.\nIf not specified, uses no-op (single orchestrator mode)."
        },
        "recovery": {
          "$ref": "#/$defs/RecoveryConfig",
          "description": "Recovery configuration for handling interrupted runs."
        },
        "blobApi": {
          "$ref": "#/$defs/BlobApiConfig",
          "description": "Blob API configuration.\nControls whether the orchestrator serves blob endpoints and the URL workers use."
        }
      }
    }
  ],
  "$defs": {
    "SupportedPluginConfig": {
      "allOf": [
        {
          "$ref": "#/$defs/SupportedPlugin"
        }
      ]
    },
    "RoutingConfig": {
      "type": "object",
      "description": "Path-keyed routing configuration",
      "required": [
        "routes"
      ],
      "properties": {
        "routes": {
          "type": "object",
          "description": "Path-to-routing rules mapping\n\nKeys describe paths. For example \"/python/{component}\" or \"/openai/{component}\".\nPlaceholders may match a single segment (e.g., \"{component}\") or multiple segments (e.g., \"{*component}\").\n\nValue: ordered list of routing rules to apply to that path.\n\nRoutes will be applied in the order they are listed, with the first matching rule being used.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "$ref": "#/$defs/RouteRule"
            }
          },
          "propertyNames": {
            "type": "string"
          }
        }
      }
    },
    "StorageConfig": {
      "oneOf": [
        {
          "type": "object",
          "description": "Expanded form: individual config per store",
          "required": [
            "metadata"
          ],
          "properties": {
            "metadata": {
              "$ref": "#/$defs/StoreConfig",
              "description": "Configuration for the metadata store"
            },
            "blobs": {
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/$defs/StoreConfig",
                  "description": "Configuration for the blob store (defaults to metadata config if not specified)"
                }
              ]
            },
            "journal": {
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/$defs/StoreConfig",
                  "description": "Configuration for the execution journal (defaults to metadata config if not specified)"
                }
              ]
            }
          }
        },
        {
          "$ref": "#/$defs/StoreConfig",
          "description": "Simple form: all stores share one backend"
        }
      ],
      "description": "Storage configuration supporting both simple and expanded forms.\n\n# Simple form (all stores share one backend)\n```yaml\nstorageConfig:\n  type: sqlite\n  databaseUrl: \"sqlite:workflow_state.db\"\n```\n\n# Expanded form (individual configs per store)\n```yaml\nstorageConfig:\n  metadata:\n    type: sqlite\n    databaseUrl: \"sqlite:workflow_state.db\"\n  blobs:\n    type: sqlite\n    databaseUrl: \"sqlite:workflow_state.db\"\n  journal:\n    type: inMemory\n```\n\nWhen multiple stores have identical configurations, they will share\na single backend instance (smart deduplication)."
    },
    "LeaseManagerConfig": {
      "oneOf": [
        {
          "type": "object",
          "description": "No-op lease management (single orchestrator mode).\n\nThis is the default for single-node deployments where there's no need\nfor distributed coordination. All lease requests succeed immediately.",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "const": "noOp"
            }
          }
        },
        {
          "allOf": [
            {
              "$ref": "#/$defs/EtcdLeaseManagerConfig",
              "description": "etcd-backed lease management for distributed deployments.\n\nUses etcd v3 for distributed coordination with one etcd lease per\norchestrator. Provides automatic cleanup on crash, push-based orphan\ndetection, and efficient `release_all` via lease revocation."
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "type": "string",
                  "const": "etcd"
                }
              }
            }
          ],
          "description": "etcd-backed lease management for distributed deployments.\n\nUses etcd v3 for distributed coordination with one etcd lease per\norchestrator. Provides automatic cleanup on crash, push-based orphan\ndetection, and efficient `release_all` via lease revocation."
        }
      ],
      "description": "Configuration for the lease manager used in distributed deployments.\n\nThe lease manager handles run ownership in multi-orchestrator scenarios,\nensuring only one orchestrator executes a given run at a time."
    },
    "RecoveryConfig": {
      "type": "object",
      "description": "Configuration for run recovery and orphan claiming.\n\nControls how the orchestrator handles interrupted runs on startup\nand during execution.",
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Whether to enable periodic orphan claiming during execution.\n\nWhen enabled, the orchestrator will periodically check for orphaned\nruns (from crashed orchestrators) and claim them for execution.\nDefault: true",
          "default": true
        },
        "checkIntervalSecs": {
          "type": "integer",
          "format": "int64",
          "description": "Interval in seconds between orphan check attempts.\n\nOnly used when `enabled` is true. Lower values mean faster recovery\nbut more overhead. Default: 30 seconds.",
          "default": 30,
          "minimum": 0
        },
        "maxStartupRecovery": {
          "type": "integer",
          "description": "Maximum number of runs to recover on startup.\n\nLimits how many interrupted runs are recovered when the orchestrator\nstarts. Set to 0 to disable startup recovery. Default: 100.",
          "default": 100,
          "minimum": 0
        },
        "maxClaimsPerCheck": {
          "type": "integer",
          "description": "Maximum number of orphaned runs to claim per check interval.\n\nLimits how many runs are claimed in each periodic check to avoid\noverwhelming a single orchestrator. Default: 10.",
          "default": 10,
          "minimum": 0
        },
        "leaseTtlSecs": {
          "type": "integer",
          "format": "int64",
          "description": "TTL in seconds for the orchestrator lease and heartbeats.\n\nThe heartbeat interval is automatically set to `lease_ttl_secs / 3`.\nIf an orchestrator stops sending heartbeats, its lease expires after this\nduration and its runs become eligible for recovery. Default: 30 seconds.",
          "default": 30,
          "minimum": 0
        }
      }
    },
    "BlobApiConfig": {
      "type": "object",
      "description": "Configuration for the Blob HTTP API.\n\nThis controls whether the orchestrator serves blob API endpoints and what URL\nworkers should use to access the blob API.",
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Whether the orchestrator serves blob API endpoints.\n\nSet to `false` when running a separate blob service.\nDefault: `true`",
          "default": true
        },
        "url": {
          "type": [
            "string",
            "null"
          ],
          "description": "URL workers use to access the blob API.\n\nIf not set, defaults to `http://localhost:{port}/api/v1/blobs` where `{port}`\nis the server's bound port.\n\nThis value should be the base blobs endpoint URL. Workers will:\n- `POST {url}` to create blobs\n- `GET {url}/{blob_id}` to fetch blobs\n\nExamples:\n- Local dev: omit (auto-detected)\n- K8s with orchestrator blobs: `http://orchestrator-service/api/v1/blobs`\n- K8s with separate blob service: `http://blob-service/api/v1/blobs`",
          "default": null
        }
      }
    },
    "SupportedPlugin": {
      "oneOf": [
        {
          "allOf": [
            {
              "$ref": "#/$defs/StepflowPluginConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "type": "string",
                  "const": "stepflow"
                }
              }
            }
          ]
        },
        {
          "allOf": [
            {
              "$ref": "#/$defs/BuiltinPluginConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "type": "string",
                  "const": "builtin"
                }
              }
            }
          ]
        },
        {
          "allOf": [
            {
              "$ref": "#/$defs/MockPlugin"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "type": "string",
                  "const": "mock"
                }
              }
            }
          ]
        },
        {
          "allOf": [
            {
              "$ref": "#/$defs/McpPluginConfig"
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "type": "string",
                  "const": "mcp"
                }
              }
            }
          ]
        }
      ]
    },
    "StepflowPluginConfig": {
      "allOf": [
        {
          "$ref": "#/$defs/StepflowTransport"
        }
      ]
    },
    "BuiltinPluginConfig": {
      "default": null
    },
    "MockPlugin": {
      "type": "object",
      "description": "A mock plugin that can be used to test various things in the plugin protocol.",
      "required": [
        "components"
      ],
      "properties": {
        "components": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/MockComponent"
          },
          "propertyNames": {
            "type": "string",
            "description": "Identifies a specific plugin and atomic functionality to execute. Use component name for builtins (e.g., 'eval') or path format for plugins (e.g., '/python/udf').",
            "examples": [
              "/builtin/eval",
              "/mcpfs/list_files",
              "/python/udf"
            ]
          }
        }
      }
    },
    "McpPluginConfig": {
      "type": "object",
      "required": [
        "command",
        "args"
      ],
      "properties": {
        "command": {
          "type": "string"
        },
        "args": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "env": {
          "type": "object",
          "description": "Environment variables to pass to the MCP server process.\nValues can contain environment variable references like ${HOME} or ${USER:-default}.",
          "additionalProperties": {
            "type": "string"
          },
          "propertyNames": {
            "type": "string"
          }
        }
      }
    },
    "StepflowTransport": {
      "oneOf": [
        {
          "type": "object",
          "description": "Subprocess mode: launch a process that runs an HTTP server.\nThe process must print {\"port\": N} to stdout when ready.",
          "required": [
            "command"
          ],
          "properties": {
            "command": {
              "type": "string"
            },
            "args": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "env": {
              "type": "object",
              "description": "Environment variables to pass to the subprocess.\nValues can contain environment variable references like ${HOME} or ${USER:-default}.",
              "additionalProperties": {
                "type": "string"
              },
              "propertyNames": {
                "type": "string"
              }
            },
            "healthCheck": {
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/$defs/HealthCheckConfig",
                  "description": "Health check configuration for the subprocess server."
                }
              ]
            }
          }
        },
        {
          "type": "object",
          "description": "Remote mode: connect directly to an existing HTTP endpoint.",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "type": "string"
            }
          }
        }
      ],
      "description": "Configuration for Stepflow plugin transport.\n\nEither `command` or `url` must be provided (but not both):\n- `command`: Launch a subprocess HTTP server\n- `url`: Connect to an existing HTTP server"
    },
    "HealthCheckConfig": {
      "type": "object",
      "description": "Configuration for health check polling when launching subprocess servers.",
      "properties": {
        "path": {
          "type": "string",
          "description": "Health check endpoint path. Default: \"/health\""
        },
        "timeoutMs": {
          "type": "integer",
          "format": "int64",
          "description": "Total timeout in milliseconds for the health check to pass. Default: 60000 (60s)",
          "minimum": 0
        },
        "retryDelayMs": {
          "type": "integer",
          "format": "int64",
          "description": "Delay between health check attempts in milliseconds. Default: 100",
          "minimum": 0
        }
      }
    },
    "MockComponent": {
      "type": "object",
      "required": [
        "input_schema",
        "output_schema",
        "behaviors"
      ],
      "properties": {
        "input_schema": {
          "$ref": "#/$defs/Schema"
        },
        "output_schema": {
          "$ref": "#/$defs/Schema"
        },
        "behaviors": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/MockComponentBehavior"
          },
          "propertyNames": {
            "allOf": [],
            "description": "Any JSON value (object, array, string, number, boolean, or null)"
          }
        }
      }
    },
    "Schema": {
      "type": "object",
      "description": "A valid JSON Schema object."
    },
    "MockComponentBehavior": {
      "oneOf": [
        {
          "type": "object",
          "description": "Produce the given internal (non-flow) error.",
          "required": [
            "error"
          ],
          "properties": {
            "error": {
              "type": "string"
            }
          }
        },
        {
          "allOf": [
            {
              "$ref": "#/$defs/FlowResult"
            }
          ],
          "description": "Return the given result (success or flow-error)."
        }
      ],
      "description": "Enumeration of behaviors for the mock components."
    },
    "FlowResult": {
      "oneOf": [
        {
          "$ref": "#/$defs/FlowResultSuccess"
        },
        {
          "$ref": "#/$defs/FlowResultFailed"
        }
      ],
      "title": "FlowResult",
      "description": "The results of a step execution.",
      "discriminator": {
        "propertyName": "outcome",
        "mapping": {
          "failed": "#/$defs/FlowResultFailed",
          "success": "#/$defs/FlowResultSuccess"
        }
      }
    },
    "Value": {
      "allOf": [],
      "description": "Any JSON value (object, array, string, number, boolean, or null)"
    },
    "FlowError": {
      "type": "object",
      "description": "An error reported from within a flow or step.",
      "required": [
        "code",
        "message"
      ],
      "properties": {
        "code": {
          "type": "integer",
          "format": "int64"
        },
        "message": {
          "type": "string"
        },
        "data": {
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/$defs/Value"
            }
          ]
        }
      }
    },
    "FlowResultSuccess": {
      "type": "object",
      "title": "FlowResultSuccess",
      "description": "The step execution was successful.",
      "required": [
        "outcome",
        "result"
      ],
      "properties": {
        "outcome": {
          "type": "string",
          "title": "FlowOutcome",
          "default": "success",
          "const": "success"
        },
        "result": {
          "$ref": "#/$defs/Value"
        }
      }
    },
    "FlowResultFailed": {
      "type": "object",
      "title": "FlowResultFailed",
      "description": "The step failed with the given error.",
      "required": [
        "outcome",
        "error"
      ],
      "properties": {
        "outcome": {
          "type": "string",
          "title": "FlowOutcome",
          "default": "failed",
          "const": "failed"
        },
        "error": {
          "$ref": "#/$defs/FlowError"
        }
      }
    },
    "RouteRule": {
      "type": "object",
      "description": "A single routing rule for a specific path",
      "required": [
        "plugin"
      ],
      "properties": {
        "conditions": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/InputCondition"
          },
          "description": "Optional input conditions that must match for this rule to apply"
        },
        "componentAllow": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          },
          "description": "Optional component allowlist - only these components are allowed to match this rule\n\nIf omitted, all components are allowed to match."
        },
        "componentDeny": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          },
          "description": "Optional component denylist - these components are blocked from matching this rule\n\nIf omitted, no components are blocked."
        },
        "plugin": {
          "type": "string",
          "description": "Plugin name to route to"
        },
        "component": {
          "type": [
            "string",
            "null"
          ],
          "description": "Component name to pass to the plugin.\nDefaults to `/{component}` if not specified, meaning the extracted component name is used.\n\nMay be a pattern referencing path placeholders, e.g., \"{component}\" or \"{*component}\"."
        }
      }
    },
    "InputCondition": {
      "type": "object",
      "description": "JSON path condition for matching specific parts of input data",
      "required": [
        "path",
        "value"
      ],
      "properties": {
        "path": {
          "$ref": "#/$defs/JsonPath",
          "description": "JSON path expression (e.g., \"$.model\", \"$.config.temperature\")"
        },
        "value": {
          "$ref": "#/$defs/Value",
          "description": "Value to match against (equality comparison)"
        }
      }
    },
    "JsonPath": {
      "type": "string",
      "description": "JSON path expression to apply to the referenced value. May use `$` to reference the whole value. May also be a bare field name (without the leading $) if the referenced value is an object.",
      "examples": [
        "field",
        "$.field",
        "$[\"field\"]",
        "$[0]",
        "$.field[0].nested"
      ]
    },
    "StoreConfig": {
      "oneOf": [
        {
          "type": "object",
          "description": "In-memory storage (default, for testing and demos).\n\n**Supported stores**: metadata, blobs, journal\n\nData is not persisted across restarts. Useful for development,\ntesting, and demos where persistence is not required.",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "const": "inMemory"
            }
          }
        },
        {
          "allOf": [
            {
              "$ref": "#/$defs/SqliteStateStoreConfig",
              "description": "SQLite-based persistent storage.\n\n**Supported stores**: metadata, blobs, journal\n\nProvides durable storage with automatic schema migrations.\nSuitable for single-instance deployments and development."
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "type": "string",
                  "const": "sqlite"
                }
              }
            }
          ],
          "description": "SQLite-based persistent storage.\n\n**Supported stores**: metadata, blobs, journal\n\nProvides durable storage with automatic schema migrations.\nSuitable for single-instance deployments and development."
        },
        {
          "allOf": [
            {
              "$ref": "#/$defs/FilesystemBlobStoreConfig",
              "description": "Filesystem-based blob storage.\n\n**Supported stores**: blobs only\n\nStores blobs as JSON files in a directory. If no directory is specified,\na temporary directory is created and cleaned up when the store is dropped.\nSuitable for local development and single-instance deployments."
            },
            {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "type": "string",
                  "const": "filesystem"
                }
              }
            }
          ],
          "description": "Filesystem-based blob storage.\n\n**Supported stores**: blobs only\n\nStores blobs as JSON files in a directory. If no directory is specified,\na temporary directory is created and cleaned up when the store is dropped.\nSuitable for local development and single-instance deployments."
        }
      ],
      "description": "Configuration for a single storage backend.\n\nEach variant documents which store types it supports:\n- **metadata**: Flow and run metadata storage\n- **blobs**: Content-addressable blob storage\n- **journal**: Execution journal for recovery"
    },
    "SqliteStateStoreConfig": {
      "type": "object",
      "description": "Configuration for SqliteStateStore",
      "required": [
        "databaseUrl"
      ],
      "properties": {
        "databaseUrl": {
          "type": "string"
        },
        "maxConnections": {
          "type": "integer",
          "format": "int32",
          "minimum": 0
        },
        "autoMigrate": {
          "type": "boolean"
        }
      }
    },
    "FilesystemBlobStoreConfig": {
      "type": "object",
      "description": "Configuration for the filesystem blob store.",
      "properties": {
        "directory": {
          "type": [
            "string",
            "null"
          ],
          "description": "Directory path for storing blobs. If not specified, a temporary directory is used."
        }
      }
    },
    "EtcdLeaseManagerConfig": {
      "type": "object",
      "description": "Configuration for the etcd lease manager.",
      "required": [
        "endpoints"
      ],
      "properties": {
        "endpoints": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "etcd endpoints (e.g., `[\"http://localhost:2379\"]`)."
        },
        "key_prefix": {
          "type": "string",
          "description": "Key prefix for all stepflow lease keys."
        }
      }
    }
  }
}