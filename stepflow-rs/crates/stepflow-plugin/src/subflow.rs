// Copyright 2025 DataStax Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
// in compliance with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under the License
// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
// or implied. See the License for the specific language governing permissions and limitations under
// the License.

//! Sub-flow submission types for in-process execution.
//!
//! This module provides types for submitting sub-flows to a parent `FlowExecutor`
//! without going through the external API. This enables efficient in-process sub-flow
//! execution where the parent and child runs share the same scheduler and executor loop.

use std::collections::HashMap;
use std::sync::Arc;

use stepflow_core::BlobId;
use stepflow_core::values::ValueRef;
use stepflow_core::workflow::{Flow, WorkflowOverrides};
use tokio::sync::{mpsc, oneshot};
use uuid::Uuid;

/// Request to submit a sub-flow to the parent executor.
#[derive(Debug)]
pub struct SubflowRequest {
    /// The sub-flow to execute.
    pub flow: Arc<Flow>,
    /// Flow ID (content hash) for the sub-flow.
    pub flow_id: BlobId,
    /// Input values for the sub-flow items.
    pub inputs: Vec<ValueRef>,
    /// Variables to pass to the sub-flow.
    pub variables: HashMap<String, ValueRef>,
    /// Optional workflow overrides.
    pub overrides: Option<WorkflowOverrides>,
    /// Maximum concurrency for the sub-flow.
    pub max_concurrency: Option<usize>,
    /// The run ID of the parent that submitted this sub-flow.
    pub parent_run_id: Uuid,
    /// The run ID to use for this sub-flow.
    ///
    /// This is generated by the submitter so they can query results even if the
    /// response channel fails. It also enables idempotent retries: if a request
    /// with the same run_id is submitted again, the executor can detect the
    /// duplicate and return the existing run's completion channel.
    pub run_id: Uuid,
    /// Channel to acknowledge the submission.
    ///
    /// Sends back the run_id once the subflow has been registered.
    /// The caller can then use `state_store.wait_for_completion(run_id)` to wait.
    pub response_tx: oneshot::Sender<Uuid>,
}

/// Error from submitting a sub-flow.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SubflowSubmitError {
    /// The submit channel was closed (executor shut down).
    ChannelClosed,
    /// The response channel was dropped before receiving a response.
    ResponseDropped,
}

impl std::fmt::Display for SubflowSubmitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SubflowSubmitError::ChannelClosed => write!(f, "submit channel closed"),
            SubflowSubmitError::ResponseDropped => write!(f, "response channel dropped"),
        }
    }
}

impl std::error::Error for SubflowSubmitError {}

/// Handle for submitting sub-flows to a parent executor.
///
/// This is held by `RunContext` and used by bidirectional handlers
/// to submit sub-flows to the parent executor. It wraps an mpsc channel
/// sender along with run hierarchy information.
///
/// `SubflowSubmitter` is cheap to clone (just clones the channel sender
/// and copies two UUIDs).
#[derive(Clone)]
pub struct SubflowSubmitter {
    tx: mpsc::Sender<SubflowRequest>,
    /// The run ID of the run that holds this submitter.
    /// Used to set the parent_run_id for submitted sub-flows.
    parent_run_id: Uuid,
    /// The root run ID for the execution tree.
    root_run_id: Uuid,
}

impl SubflowSubmitter {
    /// Create a new subflow submitter.
    ///
    /// This is internal - use [`subflow_channel`] to create a paired submitter and receiver.
    pub(crate) fn new(
        tx: mpsc::Sender<SubflowRequest>,
        parent_run_id: Uuid,
        root_run_id: Uuid,
    ) -> Self {
        Self {
            tx,
            parent_run_id,
            root_run_id,
        }
    }

    /// Get the parent run ID.
    pub fn parent_run_id(&self) -> Uuid {
        self.parent_run_id
    }

    /// Get the root run ID.
    pub fn root_run_id(&self) -> Uuid {
        self.root_run_id
    }

    /// Create a submitter for a different run context.
    ///
    /// This allows creating a submitter that uses a different `parent_run_id`
    /// while sharing the same underlying channel. Useful for subflows
    /// that need to set their own run_id as the parent for nested subflows.
    pub fn for_run(&self, run_id: Uuid) -> Self {
        Self {
            tx: self.tx.clone(),
            parent_run_id: run_id,
            root_run_id: self.root_run_id,
        }
    }

    /// Submit a sub-flow for execution.
    ///
    /// Returns the run ID once the subflow has been registered. The caller should
    /// use `state_store.wait_for_completion(run_id)` to wait for completion, then
    /// fetch results from the state store.
    ///
    /// The run_id is generated by the submitter, so even if the response channel
    /// fails, the caller can still query results from the state store using this ID.
    ///
    /// Errors:
    /// - `SubflowSubmitError::ChannelClosed` if the channel is closed. Most
    ///   often this indicates the receiver has been dropped or closed.
    /// - `SubflowSubmitError::ResponseDropped` if the response sender has been
    ///   closed. This indicates the receiver had an error between receiving the
    ///   `SubflowRequest` and sending a response. The actual error is likely
    ///   logged elsewhere.
    pub async fn submit(
        &self,
        flow: Arc<Flow>,
        flow_id: BlobId,
        inputs: Vec<ValueRef>,
        variables: HashMap<String, ValueRef>,
        overrides: Option<WorkflowOverrides>,
        max_concurrency: Option<usize>,
    ) -> Result<Uuid, SubflowSubmitError> {
        let run_id = Uuid::now_v7();
        let (response_tx, response_rx) = oneshot::channel();

        let request = SubflowRequest {
            flow,
            flow_id,
            inputs,
            variables,
            overrides,
            max_concurrency,
            parent_run_id: self.parent_run_id,
            run_id,
            response_tx,
        };

        self.tx
            .send(request)
            .await
            .map_err(|_| SubflowSubmitError::ChannelClosed)?;

        response_rx
            .await
            .map_err(|_| SubflowSubmitError::ResponseDropped)
    }
}

impl std::fmt::Debug for SubflowSubmitter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("SubflowSubmitter")
            .field("parent_run_id", &self.parent_run_id)
            .field("root_run_id", &self.root_run_id)
            .finish_non_exhaustive()
    }
}

/// Receiver handle for processing sub-flow submissions.
///
/// This is the receiving half of the subflow channel, held by `FlowExecutor`
/// and used in the execution loop to receive sub-flow submissions from
/// bidirectional handlers.
///
/// Use [`subflow_channel`] to create a paired submitter and receiver.
pub struct SubflowReceiver {
    rx: mpsc::Receiver<SubflowRequest>,
}

impl SubflowReceiver {
    /// Receive the next submit request.
    ///
    /// Returns `None` if all senders have been dropped.
    pub async fn recv(&mut self) -> Option<SubflowRequest> {
        self.rx.recv().await
    }
}

/// Create a paired subflow submitter and receiver.
///
/// The submitter can be cloned and passed to `RunContext` for bidirectional
/// handlers to submit sub-flows. The receiver should be held by `FlowExecutor`
/// to process submissions.
///
/// # Arguments
///
/// * `buffer` - Channel buffer size (number of pending submissions)
/// * `root_run_id` - The root run ID for the execution tree
pub fn subflow_channel(buffer: usize, root_run_id: Uuid) -> (SubflowSubmitter, SubflowReceiver) {
    let (tx, rx) = mpsc::channel(buffer);
    let submitter = SubflowSubmitter::new(tx, root_run_id, root_run_id);
    let receiver = SubflowReceiver { rx };
    (submitter, receiver)
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;
    use stepflow_core::ValueExpr;
    use stepflow_core::workflow::{FlowBuilder, StepBuilder};

    fn create_test_flow() -> Arc<Flow> {
        Arc::new(
            FlowBuilder::test_flow()
                .steps(vec![
                    StepBuilder::mock_step("step1")
                        .input(ValueExpr::Input {
                            input: Default::default(),
                        })
                        .build(),
                ])
                .output(ValueExpr::Step {
                    step: "step1".to_string(),
                    path: Default::default(),
                })
                .build(),
        )
    }

    #[tokio::test]
    async fn test_subflow_submitter_basic() {
        let parent_run_id = Uuid::now_v7();
        let root_run_id = parent_run_id;
        let (tx, mut rx) = mpsc::channel(10);
        let submitter = SubflowSubmitter::new(tx, parent_run_id, root_run_id);

        // Spawn a task to receive the request and acknowledge it
        let receiver_task = tokio::spawn(async move {
            let request = rx.recv().await.unwrap();
            let run_id = request.run_id;
            let _ = request.response_tx.send(run_id);
            run_id
        });

        // Submit a sub-flow
        let flow = create_test_flow();
        let flow_id = BlobId::from_flow(&flow).unwrap();
        let inputs = vec![ValueRef::new(json!({"x": 1}))];

        let run_id = submitter
            .submit(flow, flow_id, inputs, HashMap::new(), None, None)
            .await
            .unwrap();

        let received_run_id = receiver_task.await.unwrap();
        assert_eq!(run_id, received_run_id);
    }

    #[tokio::test]
    async fn test_subflow_submitter_ids() {
        let parent_run_id = Uuid::now_v7();
        let root_run_id = Uuid::now_v7();
        let (tx, _rx) = mpsc::channel(10);
        let submitter = SubflowSubmitter::new(tx, parent_run_id, root_run_id);

        assert_eq!(submitter.parent_run_id(), parent_run_id);
        assert_eq!(submitter.root_run_id(), root_run_id);
    }

    #[tokio::test]
    async fn test_subflow_submitter_for_run() {
        let parent_run_id = Uuid::now_v7();
        let root_run_id = Uuid::now_v7();
        let new_run_id = Uuid::now_v7();
        let (tx, _rx) = mpsc::channel(10);
        let submitter = SubflowSubmitter::new(tx, parent_run_id, root_run_id);

        let new_submitter = submitter.for_run(new_run_id);
        assert_eq!(new_submitter.parent_run_id(), new_run_id);
        assert_eq!(new_submitter.root_run_id(), root_run_id);
    }

    #[tokio::test]
    async fn test_subflow_channel_closed() {
        let parent_run_id = Uuid::now_v7();
        let (tx, rx) = mpsc::channel(10);
        let submitter = SubflowSubmitter::new(tx, parent_run_id, parent_run_id);
        drop(rx);

        let flow = create_test_flow();
        let flow_id = BlobId::from_flow(&flow).unwrap();

        let result = submitter
            .submit(flow, flow_id, vec![], HashMap::new(), None, None)
            .await;

        assert_eq!(result.unwrap_err(), SubflowSubmitError::ChannelClosed);
    }
}
